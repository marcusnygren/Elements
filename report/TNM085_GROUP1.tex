%______________________________________________________
%
%   LaTeX-mall för nybörjare
%
%   Konstruerad av Marcus Bergner, bergner@cs.umu.se
%
%   Vid funderingar titta längst ned i denna fil,
%   eller skicka ett mail
%______________________________________________________
%

% lite inställningar
\documentclass[10pt, titlepage, oneside, a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage[swedish]{babel}
\usepackage{amssymb, graphicx, fancyheadings}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{float}
\usepackage{amsmath,environ}
% Ursäkta lite bloat men det behövs för att få highlighting på GLSL
\lstdefinelanguage{GLSL}
{
sensitive=true,
morekeywords=[1]{
attribute, const, uniform, varying,
layout, centroid, flat, smooth,
noperspective, break, continue, do,
for, while, switch, case, default, if,
else, in, out, inout, float, int, void,
bool, true, false, invariant, discard,
return, mat2, mat3, mat4, mat2x2, mat2x3,
mat2x4, mat3x2, mat3x3, mat3x4, mat4x2,
mat4x3, mat4x4, vec2, vec3, vec4, ivec2,
ivec3, ivec4, bvec2, bvec3, bvec4, uint,
uvec2, uvec3, uvec4, lowp, mediump, highp,
precision, sampler1D, sampler2D, sampler3D,
samplerCube, sampler1DShadow,
sampler2DShadow, samplerCubeShadow,
sampler1DArray, sampler2DArray,
sampler1DArrayShadow, sampler2DArrayShadow,
isampler1D, isampler2D, isampler3D,
isamplerCube, isampler1DArray,
isampler2DArray, usampler1D, usampler2D,
usampler3D, usamplerCube, usampler1DArray,
usampler2DArray, sampler2DRect,
sampler2DRectShadow, isampler2DRect,
usampler2DRect, samplerBuffer,
isamplerBuffer, usamplerBuffer, sampler2DMS,
isampler2DMS, usampler2DMS,
sampler2DMSArray, isampler2DMSArray,
usampler2DMSArray, struct},
morekeywords=[2]{
radians,degrees,sin,cos,tan,asin,acos,atan,
atan,sinh,cosh,tanh,asinh,acosh,atanh,pow,
exp,log,exp2,log2,sqrt,inversesqrt,abs,sign,
floor,trunc,round,roundEven,ceil,fract,mod,modf,
min,max,clamp,mix,step,smoothstep,isnan,isinf,
floatBitsToInt,floatBitsToUint,intBitsToFloat,
uintBitsToFloat,length,distance,dot,cross,
normalize,faceforward,reflect,refract,
matrixCompMult,outerProduct,transpose,
determinant,inverse,lessThan,lessThanEqual,
greaterThan,greaterThanEqual,equal,notEqual,
any,all,not,textureSize,texture,textureProj,
textureLod,textureOffset,texelFetch,
texelFetchOffset,textureProjOffset,
textureLodOffset,textureProjLod,
textureProjLodOffset,textureGrad,
textureGradOffset,textureProjGrad,
textureProjGradOffset,texture1D,texture1DProj,
texture1DProjLod,texture2D,texture2DProj,
texture2DLod,texture2DProjLod,texture3D,
texture3DProj,texture3DLod,texture3DProjLod,
textureCube,textureCubeLod,shadow1D,shadow2D,
shadow1DProj,shadow2DProj,shadow1DLod,
shadow2DLod,shadow1DProjLod,shadow2DProjLod,
dFdx,dFdy,fwidth,noise1,noise2,noise3,noise4,
EmitVertex,EndPrimitive},
morekeywords=[3]{
gl_VertexID,gl_InstanceID,gl_Position,
gl_PointSize,gl_ClipDistance,gl_PerVertex,
gl_Layer,gl_ClipVertex,gl_FragCoord,
gl_FrontFacing,gl_ClipDistance,gl_FragColor,
gl_FragData,gl_MaxDrawBuffers,gl_FragDepth,
gl_PointCoord,gl_PrimitiveID,
gl_MaxVertexAttribs,gl_MaxVertexUniformComponents,
gl_MaxVaryingFloats,gl_MaxVaryingComponents,
gl_MaxVertexOutputComponents,
gl_MaxGeometryInputComponents,
gl_MaxGeometryOutputComponents,
gl_MaxFragmentInputComponents,
gl_MaxVertexTextureImageUnits,
gl_MaxCombinedTextureImageUnits,
gl_MaxTextureImageUnits,
gl_MaxFragmentUniformComponents,
gl_MaxDrawBuffers,gl_MaxClipDistances,
gl_MaxGeometryTextureImageUnits,
gl_MaxGeometryOutputVertices,
gl_MaxGeometryOutputVertices,
gl_MaxGeometryTotalOutputComponents,
gl_MaxGeometryUniformComponents,
gl_MaxGeometryVaryingComponents,gl_DepthRange},
morecomment=[l]{//},
morecomment=[s]{/*}{*/},
morecomment=[l][keywordstyle4]{\#},
}
\addtolength{\textheight}{20mm}
\addtolength{\voffset}{-5mm}
\renewcommand{\sectionmark}[1]{\markleft{#1}}

% \Section ger mindre spillutrymme, använd dem om du vill
\newcommand{\Section}[1]{\section{#1}\vspace{-8pt}}
\newcommand{\Subsection}[1]{\vspace{-4pt}\subsection{#1}\vspace{-8pt}}
\newcommand{\Subsubsection}[1]{\vspace{-4pt}\subsubsection{#1}\vspace{-8pt}}
	
% appendices, \appitem och \appsubitem är för bilagor
\newcounter{appendixpage}

\newenvironment{appendices}{
	\setcounter{appendixpage}{\arabic{page}}
	\stepcounter{appendixpage}
}{
}

\newcommand{\appitem}[2]{
	\stepcounter{section}
	\addtocontents{toc}{\protect\contentsline{section}{\numberline{\Alph{section}}#1}{\arabic{appendixpage}}}
	\addtocounter{appendixpage}{#2}
}

\newcommand{\appsubitem}[2]{
	\stepcounter{subsection}
	\addtocontents{toc}{\protect\contentsline{subsection}{\numberline{\Alph{section}.\arabic{subsection}}#1}{\arabic{appendixpage}}}
	\addtocounter{appendixpage}{#2}
}

% Ändra de rader som behöver ändras
\def\inst{teknik och naturvetenskap}
\def\typeofdoc{TNM085 - Modelleringsprojekt }
\def\course{Elements}
%\def\pretitle{Laboration 1}
\def\title{GPU-baserad fluidsimulering i realtid}
\def\name{\\ Niklas Andersson \\
Gabriel Baravdish\\
Joakim Deborg \\
Kristofer Janukiewicz \\
Marcus Nygren}

\def\graders{Anna Lombardi}
\def\handler{Ulf Sannemo}


% om du vill referera till katalogen där dina filer ligger kan du 
% använda \fullpath som kommer att vara "~username/edu..." o.s.v.
\def\fullpath{\raisebox{1pt}{$\scriptstyle \sim$}\username/\path}


% Här börjar själva dokumentet
\begin{document}

	% skapar framsidan (om den inte duger: gör helt enkelt en egen)
	\begin{titlepage}
		\thispagestyle{empty}
		\begin{large}
			\begin{tabular}{@{}p{\textwidth}@{}}
				\textbf{LINKÖPINGS UNIVERSITET \hfill \today} \\
				\textbf{Institutionen för \inst} \\
				\textbf{\typeofdoc} \\
			\end{tabular}
		\end{large}
		\vspace{70mm}
		\begin{center}
			%\LARGE{\pretitle} \\
			\huge{\textbf{\course}}\\
			\LARGE{\title} \\
			\vspace{15mm}
			\begin{large}
				\begin{tabular}{ll}
					\textbf{Av} 
					%\textbf{E-mail} & \texttt{\email} \\
					%\textbf{Sökväg} & \texttt{\fullpath} \\
				\end{tabular}
			\end{large}
			\large\name \\
			\vfill
			\large{\textbf{Handledare}}\\
			\mbox{\large{\handler}}\\ \ \\		
			\large{\textbf{Examinator}}\\
			\mbox{\large{\graders}} 
		
		\end{center}
	\end{titlepage}


	% fixar sidfot
	%\lfoot{\footnotesize{\name, \email}}
	\rfoot{\footnotesize{\today}}
	\lhead{\sc\footnotesize\title}
	\rhead{\nouppercase{\sc\footnotesize\leftmark}}
	\pagestyle{fancy}
	\renewcommand{\headrulewidth}{0.2pt}
	\renewcommand{\footrulewidth}{0.2pt}

	%Skapa sammanfattning
	\begin{abstract}
		I den här rapporten presenteras en Eulerisk implementation av Navier-Stokes ekvationer för att simulera rök, och i förlängningen även andra fluider. Beräkningarna görs i 3D på datorns GPU, medan representationen sker i 2D. 
		
		Rapporten kan användas som ett stöd inför utförandet av en egen fluidsimulering, eller som en praktisk redogörelse för Navier-Stokes ekvationer.
	\end{abstract}
	
	% skapar innehållsförteckning.
	% Tänk på att köra latex 2ggr för att uppdatera allt
	\pagenumbering{roman}
	\tableofcontents
	
	% och lägger in en sidbrytning
	\newpage

	\pagenumbering{arabic}

	% i Sverige har vi normalt inget indrag vid nytt stycke
	\setlength{\parindent}{0pt}
	% men däremot lite mellanrum
	\setlength{\parskip}{10pt}

	\Section{Introduktion}
		Elements är en programvara som utför fluidsimuleringar baserade på Navier-Stokes ekvationer i realtid på GPU. Programmet visar i dagsläget endast rök, men programmet är utformat för att i framtiden kunna byggas ut med fler simuleringar som exempelvis eld och vatten. Visionen med Elements är att användaren ska kunna utforska Navier-Stokes ekvationer genom att i realtid kunna experimentera med parametervärdena.

%		Målet med projektet har varit att utmanas tekniskt, kombinera medieteknik och datateknik, erfara modellering och simulering, och genom projektet bidra till ökad kunskap hos andra.
	
		
	\Section{Modellering}

	\Subsection{Förklaring av Navier-Stokes ekvationer}

		Navier-Stokes ekvation, ekvation $ \ref{eq:Navier-Stokes} $, och sambandet om konserverandet av massa, ekvation $ \ref{eq:Konservering av massa} $, refereras i allmänhet till Navier-Stokes ekvationer. Dessa modellerar tillsammans en fluid genom att se på fluiden som en kontinuerlig substans, det vill säga; att istället för att enskilda molekyler studeras så studers små volymelement av fluiden som kan innehålla flera molekyler. Ekvationerna i sig bygger på konservering av massa, rörelsemängd och energi och härstammar från ett antal volym- och yt-integraler över en godtycklig volym; se stycket om konservering av energi under sektion 2.2 som beskriver Reynolds Transport Theorem (RTT), ekvation $ \ref{eq:Reynolds transportteorem} $.
		
		I följande ekvationer är $ \bold u $ hastigheten 	\begin{center}
			    $ \bold u(x,y,z,t) = \begin{pmatrix}
				x'(t) \\ 
				y'(t) \\ 
				z'(t)
				\end{pmatrix} $, 
			\end{center} där $ \bold u $ indirekt beror på tiden $ t $. Variabeln $ p $ är medelvärdet av det normala trycket i $ x $-, $ y $- och $ z $-led över ett volymelement, $ \bold \Gamma $ är en generell deriverbar spänningstensor och variabeln $ \bold f $ står för yttre påverkande krafter.
	
	\begin{center}
		\begin{equation}\label{eq:Navier-Stokes}
			\bold \varrho \left ( \frac{\partial }{\partial t} \bold u + \bold u \cdot \nabla \bold u \right ) 
			=
			- \nabla p
			+ \nabla \cdot \bold \Gamma + \bold f
		\end{equation}	
		
		\begin{equation}\label{eq:Konservering av massa}
		 	\nabla \cdot \bold u = 0 
		\end{equation}
	\end{center}
			
	\Subsection{Konservering av energi}

		 RTT är en balansekvation som säger att förändringen av en fysisk egenskap $ \psi  $ (antingen skalär- eller vektor-baserad) definierad på volymen $ \Omega $ ska vara lika med skillnaden mellan vad som är förändrat genom randen till $ \Omega $ och vad som är förändrat inuti $ \Omega $ genom eventuella källor och sänkor $ \chi $. Detta i enlighet med ekvation $ \ref{eq:Reynolds transportteorem} $ och kan tolkas som ett sätt att bevara energi.
	
	\NewEnviron{Reynolds transportteorem}{%
	\begin{equation}\label{eq:Reynolds transportteorem}\begin{split}
	  \BODY
	\end{split}
	\end{equation}
	}

	\begin{Reynolds transportteorem}
	%	\frac{\partial }{\partial t}\int_{\Omega}^{ } \psi\ \mathrm{d}V  
	%		+ \int_{\partial\Omega}^{ } \psi \bold u \cdot \bold n \ \mathrm{d}A 
	%		- \int_{\Omega}^{ } \chi \ \mathrm{d}V
	%		= 
	%		0 
	%	\ \ \Leftrightarrow \\ \\
		\frac{\partial }{\partial t}\int_{\Omega}^{ } \psi\ \mathrm{d}V 
				= 
			    \int_{\Omega}^{ } \chi \ \mathrm{d}V	
				- \int_{\partial\Omega}^{ } \psi \bold u \cdot \bold n \ \mathrm{d}A 
		\ \ \Leftrightarrow \\ \\
		\frac{\partial }{\partial t}\int_{\Omega}^{ } \psi\ \mathrm{d}V 
				=
				 \int_{\Omega}^{ } \chi   \ \mathrm{d} V
				- \int_{\Omega}^{ } \nabla \cdot \left (  \psi \bold u \right ) \mathrm{d}V
		\ \ \Leftrightarrow \\ \\		
		\int_{\Omega}^{ } \frac{\partial }{\partial t} \psi\ \mathrm{d}V
				+ \int_{\Omega}^{ } \nabla \cdot \left (  \psi \bold u \right ) \mathrm{d}V
				- \int_{\Omega}^{ } \chi   \ \mathrm{d} V
				=
				0
		\ \ \Leftrightarrow \\ \\
		\int_{\Omega}^{ } \left ( \frac{  \partial }{\partial t} \psi\ 
				+ \nabla \cdot \left (  \psi \bold u \right ) 
				- \chi  \right ) \mathrm{d}V
				= 
				0	\ \ 	\ \ 	\ \ 	
	\end{Reynolds transportteorem}
		



\iffalse
	\begin{center}
		\begin{equation}\label{eq:Reynolds transportteorem}
			\frac{\partial }{\partial t}\int_{\Omega}^{ } \psi\ \mathrm{d}V 
			= 
			- \int_{\partial\Omega}^{ } \psi \bold u \cdot \bold n \ \mathrm{d}A 
			- \int_{\Omega}^{ } \chi \ \mathrm{d}V
		\end{equation}
	\end{center}
	
	\begin{center}
		\begin{equation}\label{eq:Reynolds transportteorem 2}
			\frac{\partial }{\partial t}\int_{\Omega}^{ } \psi\ \mathrm{d}V 
			= 
			- \int_{\Omega}^{ } \nabla \cdot \left (  \psi \bold u \right ) \mathrm{d}V
			- \int_{\Omega}^{ } \chi   \ \mathrm{d} V
		\end{equation}
	\end{center}

	Leibniz lag säger att vi kan flytta in derivatan.
	\begin{center}
		\begin{equation}\label{eq:Reynolds transportteorem 3}
			\int_{\Omega}^{ } \frac{\partial }{\partial t} \psi\ \mathrm{d}V
			+ \int_{\Omega}^{ } \nabla \cdot \left (  \psi \bold u \right ) \mathrm{d}V
			+ \int_{\Omega}^{ } \chi   \ \mathrm{d} V
			=
			0
		\end{equation}
	\end{center}
	
	\begin{center}
		\begin{equation}\label{eq:Leibniz-Reynolds transportteorem}
			\int_{\Omega}^{ } \left ( \frac{  \partial }{\partial t} \psi\ 
			+ \nabla \cdot \left (  \psi \bold u \right ) 
			+ \chi  \right ) \mathrm{d}V
			= 
			0
		\end{equation}
	\end{center}
\fi
	
	Eftersom integralen i ekvation $ \ref{eq:Reynolds transportteorem} $ ska vara lika med noll för alla volymer $ \Omega $ erhålls ekvation $ \ref{eq:Leibniz-Reynolds transportteorem 2} $ som blir det slutgiltiga sambandet för konservering av energi. Detta samband nyttjas i framtagandet av Navier-Stokes ekvationer genom att applicera det på  massa respektive rörelsemängd.
	
	\begin{center}
		\begin{equation}\label{eq:Leibniz-Reynolds transportteorem 2}
			\frac{  \partial }{\partial t} \psi\ 
			+ \nabla \cdot \left (  \psi \bold u \right ) 
			- \chi 
			= 
			0
		\end{equation}
	\end{center}
	
	
	\Subsection{Konservering av massa}
	Enligt RTT blir $ \psi = \varrho $ vid konservering av massa och då det inte finns några källor eller sänkor av massa blir $ \chi = 0 $, vilket ger ekvation $ \ref{eq:Konservering av massa 1} $.
	
	\begin{center}
		\begin{equation}\label{eq:Konservering av massa 1}
			\frac{  \partial }{\partial t} \varrho \ 
			+ \nabla \cdot \left (  \varrho \bold u \right ) 
			= 
			0
		\end{equation}
	\end{center}
	
	Om $ \varrho $ fixeras till en konstant leder det till att $ \frac{  \partial }{\partial t} \varrho \  = 0 $ och att $ \nabla \cdot \left (  \varrho \bold u \right ) = 0 $. Det senare villkoret leder fram till sambandet om konserverandet av massa, se ekvation $ \ref{eq:Konservering av massa} $, som ofta ackompanjerar Navier-Stokes ekvation, $ \ref{eq:Navier-Stokes} $. Sambandet innebär att fluiden är inkompressibel, det vill säga att fluiden alltid behåller sin ursprungliga volym.

	\Subsection{Konservering av rörelsemängd}
	För rörelsemängd, $ p = m\bold u $, fås enligt RTT att $ \psi = \varrho \bold u $, vilket ger ekvation $ \ref{eq:Konservering av rörelsemängd} $.
	
	\begin{center}
		\begin{equation}\label{eq:Konservering av rörelsemängd}
			\frac{  \partial }{\partial t} \varrho \bold u \ 
			+ \nabla \cdot \left ( \varrho \bold u  \bold u \right ) 
			- \chi 
			= 
			0
		\end{equation}
	\end{center}
	
	Utveckling av ekvation $ \ref{eq:Konservering av rörelsemängd} $ ger ekvation $ \ref{eq:Konservering av rörelsemängd 2} $, där $ \chi $ representerar en källa eller sänka. 
	
	\begin{center}
		\begin{equation}\label{eq:Konservering av rörelsemängd 2}
			\bold u \frac{  \partial }{\partial t} \varrho \ 
			+ \varrho \frac{  \partial }{\partial t} \bold u \ 
			+ \bold u  \bold u \  \cdot \nabla \varrho
			+ \varrho \bold u \cdot \nabla \bold u
			+ \varrho \bold u \nabla \cdot \bold u
			= \chi
		\end{equation}
	\end{center}
		
	Ytterligare omskrivning av ekvation $ \ref{eq:Konservering av rörelsemängd 2} $ ger ekvation $ \ref{eq:Konservering av rörelsemängd 3} $.
	
	\begin{center}
		\begin{equation}\label{eq:Konservering av rörelsemängd 3}
			\bold u \left ( \frac{  \partial }{\partial t} \varrho + \bold u \cdot \nabla \varrho + \varrho \nabla \cdot \bold u \right ) 
			+ \varrho \left ( \frac{  \partial }{\partial t} \bold u 
			+ \bold u \cdot \nabla \bold u \right )
			= \chi
		\end{equation}
	\end{center}
	
	I vänsterledet i ekvation $ \ref{eq:Konservering av rörelsemängd 3} $ innehåller den första termen sambandet om konservering av massa, ekvation $ \ref{eq:Konservering av massa 1} $, då
	$ \bold u \cdot \nabla \varrho + \varrho \nabla \cdot \bold u 
	= \nabla \cdot \left ( \varrho \bold u \right ) $. Detta medför att denna term måste vara lika med noll, vilket innebär att kvar blir ekvation $ \ref{eq:Konservering av rörelsemängd 4} $.

	\begin{center}
		\begin{equation}\label{eq:Konservering av rörelsemängd 4}
			 \varrho \left ( \frac{  \partial }{\partial t} \bold u 
			+ \bold u \cdot \nabla \bold u \right )
			= \chi
		\end{equation}
	\end{center}
	
	En anekdot är att utveckling av ekvation $ \ref{eq:Konservering av rörelsemängd 4} $ ger ett samband som kan knytas till Newtons andra lag, $ \bold F = m \bold a $, se ekvation  $ \ref{eq:Konservering av rörelsemängd 6} $, där $ \varrho $ representerar massan $ m $, $ \chi $ yttre krafter $ \bold F $ och där materialderivatan för $ \bold u $ representerar accelerationen $ \bold a $. 

	\NewEnviron{Konservering av rörelsemängd 6}{%
	\begin{equation}\label{eq:Konservering av rörelsemängd 6}\begin{split}
 \BODY
	\end{split}
	\end{equation}
	}
	\begin{Konservering av rörelsemängd 6}
			\varrho \left ( 
			\frac{\partial \bold u }{\partial t}
			+  u _{x} \frac{\partial u _{x}} {\partial x} 
			+  u _{y} \frac{\partial u _{y}} {\partial y} 
			+  u _{z} \frac{\partial u _{z}} {\partial z} 
			\right )
			=
			\chi
		\ \ \Leftrightarrow \\ \\
			\varrho \
			\frac{\mathrm{d} }{\mathrm{d} t} 
			\bold u(x,y,z,t)
			=
			\chi \ \ \ \ \ \
	\end{Konservering av rörelsemängd 6}
	
	\iffalse
	\begin{center}
		\begin{equation}\label{eq:Konservering av rörelsemängd 5}
			\varrho \left ( 
			\frac{\partial \bold u }{\partial t}
			+  u _{x} \frac{\partial u _{x}} {\partial x} 
			+  u _{y} \frac{\partial u _{y}} {\partial y} 
			+  u _{z} \frac{\partial u _{z}} {\partial z} 
			\right )
			=
			\chi
		\end{equation}
	\end{center}

	\begin{center}
		\begin{equation}\label{eq:Konservering av rörelsemängd 6}
			\varrho \
			\frac{\partial }{\partial t} 
			\bold u(x,y,z,t)
			=
			\chi
		\end{equation}
	\end{center}
	\fi
	
	Genom att studera ett fluidelement i en fluid fås att kraften $ \chi $ kan delas upp i två termer enligt $ \chi =   \nabla \cdot \sigma + \bold f $, där $ \nabla \cdot \sigma $ härstammar från tryck och där $ \bold f $ härstammar från yttre krafter. Cauchys spänningstensor $ \sigma $ kan förenklas till $ \sigma = -pI +  \bold \Gamma \ $, där $ p $ är medelvärdet av det normala trycket i $ x $-, $ y $- och $ z $-led, $ I $ är identitetsmatrisen och där $ \bold \Gamma $ är en deriverbar spänningstensor som brukligt kallas för viskositetstermen. För en fluid i vila är exempelvis $ \bold \Gamma = 0 $. Detta resulterar i ekvation $ \ref{eq:Konservering av rörelsemängd 9} $ som är Navier-Stokes generella ekvation.
	
	\NewEnviron{Konservering av rörelsemängd 9}{%
	\begin{equation}\label{eq:Konservering av rörelsemängd 9}\begin{split}
 \BODY
	\end{split}
	\end{equation}
	}
	\begin{Konservering av rörelsemängd 9}
			 \varrho \left ( \frac{  \partial }{\partial t} \bold u 
			+ \bold u \cdot \nabla \bold u \right )
			= 
			\nabla \cdot \sigma + \bold f
		\ \ \Leftrightarrow \\ \\
			 \varrho \left ( \frac{  \partial }{\partial t} \bold u 
					+ \bold u \cdot \nabla \bold u \right )
					= 
					\nabla \cdot \left ( -pI +  \bold \Gamma \right ) + \bold f
		\ \ \Leftrightarrow \\ \\
		\varrho \left ( \frac{  \partial }{\partial t} \bold u 
			+ \bold u \cdot \nabla \bold u \right )
			= 
			- \nabla p + \nabla \cdot \bold \Gamma  + \bold f	
			\ \ \
	\end{Konservering av rörelsemängd 9}

\iffalse

	\begin{center}
		\begin{equation}\label{eq:Konservering av rörelsemängd 7}
			 \varrho \left ( \frac{  \partial }{\partial t} \bold u 
			+ \bold u \cdot \nabla \bold u \right )
			= 
			\nabla \cdot \sigma + \bold f
		\end{equation}
	\end{center}
	
	\begin{center}
		\begin{equation}\label{eq:Konservering av rörelsemängd 8}
		 \varrho \left ( \frac{  \partial }{\partial t} \bold u 
			+ \bold u \cdot \nabla \bold u \right )
			= 
			\nabla \cdot \left ( -pI +  \bold \Gamma \right ) + \bold f
		\end{equation}
	\end{center}
	
	\begin{center}
		\begin{equation}\label{eq:Konservering av rörelsemängd 9}
	 \varrho \left ( \frac{  \partial }{\partial t} \bold u 
			+ \bold u \cdot \nabla \bold u \right )
			= 
			- \nabla p + \nabla \cdot \bold \Gamma  + \bold f
		\end{equation}
	\end{center}
\fi	

	\Section{Numerisk implementation}
	
		\Subsection{Val av beräkningsmetod}
		
			Det finns två olika sätt att basera sina beräkningar på, det Euleriska synsättet och det Lagranska synsättet. Det Lagranska synsättet ser fluiden som ett partikelsystem, där en partikel kan likställas med ett fluidelement som rör på sig och som går att associera med en enskild molekyl. Till skillnad från det Lagranska synsättet där enskilda partiklar studeras, bygger istället det Euleriska synsättet på att fixerade punkter i rummet studeras. Fluidens egenskaper som exempelvis hastighet, densitet och temperatur beräknas i varje given punkt.

			Vid fluidsimuleringar på GPU lämpar det sig bäst att använda sig av det Euleriska synsättet, eftersom de intressanta punkterna i rymden med fördel kan placeras i ett rutnät som direkt kan representeras av en textur. Således tillämpas det Euleriska synsättet i det här projektet.

		\Subsection{Implementation av Navier-stokes ekvationer}

			För simulering av rök förenklas systemet i ekvation $\ref{eq:Navier-Stokes}$. Först inses att spänningstensorn $ \\\\\bold \Gamma $  är försumbar för simulering av rök. Därefter divideras höger -och vänsterledet med $\rho$, för att sedan flytta över $\bold u \cdot \nabla \bold u$ till högerledet. Resultatet blir då ekvation $\ref{eq:Navier-Stokes simple}$, med villkoret $\ref{eq:Konservering av massa}$. Mer teori och bakgrund om röksimulering finns att hämta i referens \cite{GPUGems1} och \cite{Fedkiw}.

	\begin{center}
		\begin{equation}\label{eq:Navier-Stokes simple}
			\frac{du}{dt}= -(\bold u \cdot \nabla \bold u) - \frac{1}{ \rho } 				\nabla p + \bold f
		\end{equation}
	\end{center}
	
	Ekvation $ \ref{eq:Navier-Stokes simple} $ kan brytas ned och beräknas komponentvis. Där 
 	$ \bold u \cdot \nabla \bold u $ beskriver advektion av hastigheten, $ \nabla p $  tryckförändringen i rummet och $\bold f $ är en lämplig extern kraft som verkar på rök. För varje komponent uppdateras rutnätet stegvis tills alla komponenter har beräknats, för att därefter påbörja en ny beräkning.
	
	Den första komponenten som beräknas är advektionen. Advektion av en fysikalisk kvantitet kan beräknas numerisk med olika metoder. En användbar stegmetod för fluider är Eulers implicita stegmetod. Då Eulers explicita metod tenderar att ge okontrollerbar ökning av felet så är den implicita metoden stabil för vissa valda tidssteg och enkel att implementera på GPU:n. Advektionen beräknas genom att spåra kvantiteten till en punkt bakåt i tiden. Därefter beräknas en billinjär interpolation på dem fyra närliggande värdena i rutnätet.

	När adkvetion har genomförts beräknas den andra komponenten, trycket. Trycket beräknas genom att först skapa en vektor $\bold w$, som en summa av två vektorer, enligt ekvation  $ \ref{eq:vektor w} $:

	\begin{center}
		\begin{equation}\label{eq:vektor w}
			\bold w = \bold u + \nabla p.
		\end{equation}
	\end{center}
	
	Därefter appliceras divergensoperatorn på ekvation $ \ref{eq:vektor w} $ och tillsammans med villkoret $ \ref{eq:villkor} $ blir resultatet ekvation $ \ref{eq:Poissons ekvation} $, Poissons ekvation.
	
	\begin{center}
		\begin{equation}\label{eq:Poissons ekvation}
			\nabla ^2 p = \nabla \cdot \bold w 
		\end{equation}
	\end{center}
	
	I ekvation $ \ref{eq:Poissons ekvation} $ står $\bold w$ för hastigheten som hittills räknats ut av dem tidigare komponenterna i ekvationen. Poissons ekvation kan skrivas om till matrisform, $ \bold A \bold x = \bold b $, där $\bold A $ byggs av Laplaceoperatorn, $ \bold b $ är konstanter från $ \bold w $ och $ \bold x $ är vektorn med sökta element. Metoden som används för att lösa systemet är Jacobis iterativa metod. Metoden går ut på att först initiera en gissning på en lösning av systemet och sedan iterera fram en förbättrad lösning. Processen är iterativ tills lösningen konvergerar. Det finns olika numeriska metoder till att lösa Poissons ekvation, men tack vare Jacobis enkla struktur utförs beräkningarna snabbt på GPU:n, även om metoden konvergerar långsammare än andra metoder.
	
	För en fullständig lösning på Poissons ekvation krävs hantering av tryck- och hastighets-problem som uppstår vid randen. Hastigheten i randens riktning sätts då till 0 och för trycket används Neumanns randvillkor, på så sätt att $ \frac{\partial p}{\partial t} = 0 $. 

	Slutligen uppdateras hastigheten med externa krafter. Det finns olika lämpliga externa krafter som verkar på rök. Men för enkelhetens skull har bara en kraft tagits med i implementationen, rökens lyftkraft. Det är en kraft som återfinns i verkliga sammanhang och som beror av temperaturen i rummet och gasens densitet. 
	
	% Mer om hur man tar fram temperaturen och densiteten 	
	\iffalse
	 Temperatur- och densitetsförändringen ges av ekvationerna $ \ref{eq:Temperatur} $ respektive $ \ref{eq:Densitet} $

	\begin{center}
		\begin{equation}\label{eq:Temperatur}
			\frac{\partial T}{\partial t} = -(\bold u \cdot \nabla)T,			
		\end{equation}
	\end{center}
	\begin{center}
		\begin{equation}\label{eq:Densitet}
			\frac{\partial \rho}{\partial t} = -(\bold u \cdot \nabla)\rho.	 
		\end{equation}
	\end{center}
\fi

	Från ekvation $\ref{eq:Navier-Stokes simple}$ kan den externa kraften, $ \bold f$, beräknas genom ekvation $\ref{eq:Buoyancy}$.
	\begin{center}
		\begin{equation}\label{eq:Buoyancy}
			\bold f_{buoy} = - \alpha\rho\bold y + \beta(T-T_{amb})\bold y
		\end{equation}
	\end{center}

I $ \ref{eq:Buoyancy} $ är $ \alpha $ och $ \beta $ positiva konstanter så att ekvationen är fysikalisk meningsfull. Temperaturen och den initiala temperaturen är $ T $ respektive $ T_{amb} $. Riktningen hos kraften är $ \bold y = (0,1,0) $. Djupare teori om framtagning av temperatur och densitet finns att se i referens \cite{Fedkiw}. 



		\Subsection{Simulering i MATLAB}
	MATLAB är ett verktyg med inbyggda kommandon som underlättar  beräkningar av matriser. Med programmets kommandon kan en enklare flödessimulering utföras som en förstudie och ökad förståelse. Det är dock svårt att verifiera om en simulering utförs korrekt eftersom programmet saknar visuell funktionalitet. 
\\
\\	
I MATLAB användes samma steg som beskrivs i avsnitt 3.1 Implementation av Navier-Stokes ekvationer. Till skillnad från simuleringen som beskrivs i avsnitt 3.3 OpenGL/GLSL, simplifierades det visuella utseendet för att lösa och förstå de numeriska problem som kunde uppstå. Simuleringen visade bland annat att tidsteget gav varierande resultat och var känslig för mindre ändringar. Det insågs också att $ \alpha $ och $ \beta $ i ekvation $ \ref{eq:Buoyancy} $ har en kraftig påverkan på ekvationen. 
	
		\Subsection{OpenGL/GLSL}
		Realtidssimuleringar av fluider är mycket krävande även för dagens moderna datorer, vilket innebär att metoder för bättre prestanda är eftertraktade. En sådan teknik är att implementera den numeriska lösningen på GPU (istället för CPU), för att utnyttja möjligheten att köra beräkningarna parallellt. Även på moderna processorer är det möjligt att utföra beräkningar parallellt på fyra eller till och med åtta kärnor, dock kan detta inte mäta sig med de upp emot 2500 beräkningskärnor som kan tillgås på ett nyare grafikkort.
		
		För GPU-implementationen användes programmeringsspråket C++ med grafikbiblioteket OpenGL för att styra programmet på applikationsnivå. För att komma närmare hårdvaran och kontrollera hur grafikkortet utförde beräkningarna användes även språket GLSL. 

		För att beskriva simuleringen behövdes att antal värden sparas för varje cell i volymen. Dessa värden kan intuitivt representeras som 3D-texturer med olika många komponenter per voxel (volymelement).  Till exempel så kan en hastighet i tre dimensioner lagras som en vektor med tre komponenter. För att spara en hastighet för varje cell i volymen användes en 3D-textur där varje voxel innehåller tre komponenter. För att bestämma hur många komponenter en textur skulle ha användes OpenGL-funktionen i listing~\ref{lst::texImage}. 
\begin{lstlisting}[language=C++, caption = {OpenGL-funktionen för att skapa en 3D-textur.}, label = {lst::texImage}]
void glTexImage3D(
	GLenum target,
 	GLint level,
 	GLint internalFormat,
 	GLsizei width,
 	GLsizei height,
 	GLsizei depth,
 	GLint border,
 	GLenum format,
 	GLenum type,
 	const GLvoid * data);
\end{lstlisting}

De parametrar som kontrollerar antalet komponenter är internalFormat och format. I tabell~\ref{tbl:texturer} visas en lista över de texturer som användes, hur många komponenter de hade och vilka värden som användes på de ovan nämnda parametrarna.

\begin{table}[h]
\begin{center}
\caption{Lista över de olika texturerna som används.}
\label{tbl:texturer}
	 \begin{tabular}{| l | l | l | l |}
	 \hline
		Storhet & Komponenter & internalFormat & format \\ \hline
		Hastighet & 3 & GL\_RGB16F & GL\_RGB \\ \hline
		Densitet & 3 & GL\_RGB16F & GL\_RGB \\ \hline
		Tryck & 1 & GL\_R16F & GL\_RED \\ \hline
		Divergens & 1 & GL\_R16F & GL\_RED \\ \hline
		Temperatur & 1 & GL\_R16F & GL\_RED \\ \hline
	\end{tabular}
\end{center}
\end{table}
För att kunna representera hinder användes ytterligare en 3D-textur. För detta krävdes endast en textur med en komponent. Om värdet i denna komponent var större än noll ansågs den voxeln i volymen att ligga i ett hinder. 
För en mer omfattande beskrivning av hur texturer skapas i OpenGL se referens \cite[s.~138]{OpenGLSuperBible}. \\

För att sedan kunna uppdatera värdena i texturerna användes så kallade \textit{Framebuffer Objects}. Med \textit{Framebuffer Objects} kunde resultatet från grafikkortets beräkningar sparas i texturer i stället för att ritas på skärmen. Varje textur binds till ett \textit{Framebuffer Object} som sedan kan aktiveras före rendering. Ett problem som behövde hanteras var att OpenGL inte kan rendera direkt till en 3D-textur. Istället behövde texturen delas in i tvådimensionella skivor som sedan renderades till var för sig. För att uppnå maximal prestanda och minska belastningen på CPU användes OpenGL funktionen i listing~\ref{lst:drawInstanced}.

\begin{lstlisting}[language=GLSL, caption={OpenGL funktion för att rendera flera instanser.}, label = {lst:drawInstanced}]
void glDrawArraysInstanced(
	GLenum mode,
	GLint first,
 	GLsizei count,
 	GLsizei primcount); 
\end{lstlisting}

Parametern mode talar om vilken typ av primitiv som ska renderas och sattes i detta fall till GL\_TRIANGLE\_STRIP. first talar om var i vertex-listan renderingen ska starta. För den parametern sattes värdet noll då renderingen skulle börja från början av listan. Eftersom det var en quad som ritades sattes count till fyra, det vill säga antalet hörnpunkter som skulle renderas. Den mest intressanta parametern är primcount då den talar om hur många instanser av som ska göras av renderingen. Då volymen delades upp i z-led sattes primcount till djupet på volymen. Vid instansrendering ökas värdet på den inbyggda vertex-shader variabel \textit{gl\_InstanceID} med ett för varje instans. För att använda den variabeln skapades en vertex-shader som sparade den till en \textit{Output} variabel och skickade den vidare till en geometry-shader. Vertex-shader visas i listing~\ref{lst:vertex}. 

\begin{lstlisting}[language=GLSL, caption={Vertex-shader för att hantera instansrendering}, label = {lst:vertex}]
layout (location = 0) in vec4 vertexPosition;
flat out int layerInstance;

void main()
{
  layerInstance = gl_InstanceID; 
  gl_Position = vertexPosition;

}
\end{lstlisting}

En geometry-shader behandlar, till skillnad från vertex-shader, inte enstaka hörnpunkter utan istället hela primitiver. I detta fall användes den för att koppla en instans av renderingen till rätt texturlager. Första steget var att sätta den inbyggda variabeln \textit{gl\_Layer} till värdet på den aktuella instansen. \textit{gl\_Layer} talar om för OpenGL till vilket lager i texturen som är bunden till den aktiverade \textit{Framebuffer Object} som renderingen ska ske. Nästa steg var att ta fram det värdet som skulle användas för åtkomst till ett lager i en bunden textur. Detta kunde inte vara samma som \textit{gl\_Layer} då varje voxel behandlas från centrum men värdet från en textur hämtas från kanten. Detta löstes genom att introducera en förskjutning på 0.5 till värdet på \textit{gl\_Layer}. Slutligen skickade geometry-shadern hörnpunkterna vidare till nästa steg i renderingen. Shadern visas i listing~\ref{lst:geom}.

\begin{lstlisting}[language=GLSL, caption={Geometry-shader för att välja rätt texturlager.}, label = {lst:geom}]
layout(triangles) in;
layout(triangle_strip, max_vertices = 3) out;
 
flat in int layerInstance[3];
out float layer;
 
void main()
{
    gl_Layer = layerInstance[0];
    layer = float(gl_Layer) + 0.5;

    for (int i = 0; i < gl_in.length(); i++)
    {
        gl_Position = gl_in[i].gl_Position;
        EmitVertex();
    }
    EndPrimitive();
}
\end{lstlisting}

De ovan beskrivna vertex- och geometry-shaders är gemensamma för alla beräkningar som utfördes på GPU. Varje beräkning implementerades sedan som en egen fragment-shader. Nedan följer korta beskrivningar av dessa fragment-shaders i den ordning de körs i programmet. Alla konstanter som användes vid i implementationen listats i Bilaga A, tabell~\ref{tbl:konstanter}.

Advektions-termen implementerades i en shader som beräknade det nya värdet på en plats i volymen genom att använda Eulers implicita metod. Med hjälp av texturen som innehöll information om hinder kunde det avgöras om en voxel låg i ett hinder och i så fall sattes värdet där till noll.

För att beräkna lyftkraften som orsakas av temperaturen i volymen implementerades ekvation~\ref{eq:Buoyancy} i en fragment-shader. Utöver ekvation~\ref{eq:Buoyancy} implementerades även en term för rumstemperatur som gör så att en starttemperatur från början finns i hela volymen. Detta gjordes genom att jämföra om temperaturen i en punkt var mindre än rumstemperaturen och i så fall låta hastigheten vara oförändrad.

	\begin{figure}[H]
    	\centering
    	\includegraphics[scale=0.94]{report_images/warm_cold.png}
    	\caption{\emph{Lyftkraften av rök beror på temperaturen av källan. Kallare temperaturer gör att röken sjunker, lik dimma (1) och en varmare temperatur skapar en stigande rök (2) likt den som skapas vid bränder.}}
   		\label{fig:warm_cold}
	\end{figure}

Nästa steg var att lägga till källor av olika slag. Samma fragment-shader kunde användas för att lägga till olika typer av källor så som densitet och temperatur men även för att lägga till hinder. Shadern ritade en sfär med en given radie på en given plats i en textur. Genom att använda alpha-blending kunde de nya värden blandas ihop med de gamla som redan låg i texturen och på så vis ge upphov till en källa.

Sedan beräknades divergensen av hastigheten, se högerledet i ekvation~\ref{eq:Poissons ekvation}. Detta beräknades med central differensen av alla omkringliggande värden ur hastighets-texturen. Innan beräkningen utfördes kontrollerades om någon av de omkringliggande värde befann sig i ett hinder. Om så var fallet sattes hastigheten där till noll.

För att beräkna trycket ur ekvation~\ref{eq:Poissons ekvation} användes som nämnt Jacobi-iteration. I en fragment-shader implementerades en iteration som sedan kördes i en loop. Kring 20 iterationer visade sig ge ett bra resultat. På samma sätt som för divergensen användes de omkringliggande värdena fast denna gång för trycket. Ekvationen för att uppdatera trycket under en iteration visas i ekvation~\ref{eq:jacobiIteration} där $ \alpha $ och $ \beta $ är konstanter, se tabell~\ref{tbl:konstanter}, och $ b_{i,j} $ är divergensen.

	\begin{center}
		\begin{equation}\label{eq:jacobiIteration}
			p_{i,j} = (p_{x+1} + p_{x-1} + p_{y+1} + p_{y-1} + p_{z+1} + p_{z-1} + \alpha \cdot b_{i,j}) \cdot \beta
		\end{equation}
	\end{center}
	
Sista steget i beräkningen var att beräkna gradienten av trycket och subtrahera den med hastigheten. Detta kommer från att den slutgiltiga hastigheten, $ \bold u $, fås av att i ekvation~\ref{eq:vektor w} flytta $ \nabla p $ till vänsterledet. Ytligare en gång hämtades alla omkringliggande värden ur tryck-texturen och dessa användes för att beräkna gradienten. Här kontrolleras även i fall någon omkringliggande cell befinner sig i ett hinder. I så fall sätts trycket till värdet i den centrala cellen och hastigheten sätts till noll.
		
	\Section{Grafisk implementation}
		
		\Subsection{Användargränssnitt}
För att utveckla och skapa ett användagränssnitt i C++ rekommenderas ofta Qt. Det är ett populärt multiplattformsbibliotek för att utveckla GUI:n, med ett egenutvecklat designskriptspråk, QML. Detta språket kommunicerar med C++ via en metod kallad ''Signals \& Slots'' och kan även hantera JavaScript-funktioner.

		%Det upptäcktes dock att medan Qt lämpar sig väldigt väl för att göra ett avancerat GUI, vilket var ett av projektens önskemål, lämpar sig inte biblioteket för att göra avancerad 3D i OpenGL, främst därför att Qt styr över i vilken ordning olika operationer ska utföras, vilket kan vara en försvårande omständighet i mer avancerade grafikapplikationer.

		Inom projektet utvecklades fortfarande ett fungerande GUI som visade på funktionaliteten att användaren via interaktion med till exempel knappar kan kommunicera med C++-lagret. Tyvärr används inte denna implementation alls i resultatet av projektet, då vårt slutgiltiga bibliotek GLFW och Qt inte är kompatibla med varandra. Det skulle vara möjligt att använda Qt, förutsatt att man i början av projektet lägger mycket tid på att abstrahera C++-applikationen och Qt-gränssnittet, och anpassar sig efter de förutsättningar som finns.
				

		\begin{figure}[H]
			\centering
			\includegraphics[width=90mm]{report_images/QtGui}
			\caption{\emph{Användargränsnittet skapat i Qt som inte kom med i slutresultatet}}
			\label{fig:QtGui}
		\end{figure}
		
		\Subsection{GLFW}
		
		GLFW är ett plattformsoberoende fönsterhanterings-ramverk utan onödiga finesser. GLFW har inte något inbyggt stöd för att göra GUI, men är ett mycket uppskattat ramverk bland utvecklare för att utveckla prestandatunga applikationer i OpenGL. Det som GLFW kan sköta är fönsterhantering och inmatning från bland annat mus och tangentbord.
		
		När GLFW används vid utveckling av en OpenGL-applikationer behövs först ett annat ramverk för att ladda de OpenGL-funktioner som finns tillgängliga på systemet. För detta ändamål användes GLEW. I den här rapporten kommer inte GLEW att beskrivas i detalj. Det finns många bibliotek med samma funktionalitet och valet mellan dessa spelar inte någon större roll.
		
		\Subsection{3D-texturer}

		Resultatet från den numeriska lösningen är en 3D-textur som innehåller diskreta värden för densitetens utbredning i fluiden. 3D-texturen visualiseras genom att ett 2D-plan plockas ut vid ett diskret z-värde i mitten av volymen för att sedan mappas till en quad som täcker hela \textit{viewport}:en. Detta görs genom att rendera två trianglar som tillsammans bildar en rektangel och fyller hela skärmen. Hörnpunkterna skickas sedan till en vertex-shader som inte utför några beräkningar utan endast skickar den vidare. Det är först när de enskilda fragmenten ska behandlas som något meningsfullt sker. Här behandlas varje fragment av en fragment-shader som hämtar ett värde ur den bundna 3D-texturen beroende på fragmentets koordinater samt vilken nivå i z-led som ska visas. Viktigt att notera är att fragmentets koordinater antar värden mellan noll och fönstretsstorlek medan texturkoordinater ges mellan noll och ett. Det är alltså nödvändigt för fragment-shadern att veta om fönstret storlek så att koordinaterna kan normaliseras. Fragment-shadern syns i listing~\ref{lst:vizShader}.

\begin{lstlisting}[language=GLSL, caption={Fragment-shader för att visualisera ett lager ur en 3D-textur.}, label = {lst:vizShader}]
out vec3 color;
uniform sampler3D tex;
uniform float layer;
uniform vec3 dimensions;
uniform vec2 windowSize;

void main()
{
  color = texture(tex, vec3(gl_FragCoord.x / windowSize.x ,
  gl_FragCoord.y / windowSize.y, layer/dimensions.z)).xyz;
}
\end{lstlisting} 


	Den ovan nämnda metoden för att visualisera innehållet i en 3D-textur användes för att den är mycket lätt att implementera, dock går en stor del av meningen med att utföra simuleringen i tre dimensioner förlorad. Ett mer tilltalande alternativ hade varit att visualisera hela volymen i tre dimensioner med hjälp av volymrendering. Detta hade dock krävt betydligt mer implementation, vilket var utanför denna kurs ramar.
	
	\Section{Diskussion}
		
		Från början gick projektet ut på att utveckla ett gränssnitt i Qt där användaren grafiskt fick modifiera parametrarna och dess värden i Navier-Stokes, med syftet att ge användaren en väldigt pedagogisk koppling mellan ekvationerna och dess visuella representation.

		Om vi hade gjort om projektet hade vi istället utvecklat applikationen direkt i GLFW med tanke på att kursens tyngd låg i att utforma modellering och simulering, ej att producera en färdig produkt. Alldeles för sent i projektet upptäcktes varför det var så svårt att få en fungerande avancerad grafiska applikationer att fungera i Qt. Så fort projektet bytte fokus till GLFW gick det mycket snabbare att utveckla, även om det innebar att allt GUI-arbete bortprioriterades.

		Med det sagt lämpar sig Qt fortfarande väl för tunga C++-applikationer som gynnas av användargränssnitt, men kraven på hur man utformar programvaran blir mycket högre och en kalkylerad avvägning rekommenderas. För utvecklingsteamet var det uppskattat att lära sig både Qt och GLFW under en och samma projekt. Det har dock fått följden att gruppen inte kommit så långt som visionen varit i något av systemen. 
		
		Den inledande idéen var att ha flera olika fluider, större användarkontroll, 3D-representation samt fler externa krafter representerade och dess värden modifierbara. Resultatet bedöms ändå som framgångsrikt, då de kunskapsmässiga målen för kursen överträffats och vi är nöjda med vår representation. Att göra applikationen GPU-baserad visade sig vara ett effektivt val. Simuleringen kör i realtid, så det går att interagera med den via piltangenterna, vilket inte hade varit möjligt annars. 

	\Section{Resultat}
		
		I figurerna ~\ref{fig:resultat2} och ~\ref{fig:resultat} visas resultatet av att rendera ett lager av 3D-texturen som innehåller densitetens utbredning. De tre rökkällorna har olika densitet, där röken efter en tid breder ut sig och krockar med de cirkulära objekten. En värmekälla är placerad vid samma position som rökkällan i mitten i figur ~\ref{fig:resultat}. Detta kan ses i figuren genom att observera hur röken på den vänstra och högra sidan rör sig i motsatt riktning till värmekällan. Implementationen tillåter en användare att styra den mittersta källan via piltangenterna, se exempel i figur ~\ref{fig:resultat2}. Vissa tangenter är även bundna till att ändra värden hos parametrarna, exempelvis temperatur, som i detta fall är inställda enligt tabell ~\ref{tbl:konstanter} i bilaga A.
	
	\begin{figure}[H]
    	\centering
    	\includegraphics[width=\linewidth]{report_images/Simulering3.png}
    	\caption{\emph{Resultat av simuleringen vid startstadium.}}
   		\label{fig:resultat}
	\end{figure}		
		
		\begin{figure}[H]
    	\centering
    	\includegraphics[width=\linewidth]{report_images/Simulering2.png}
    	\caption{\emph{Resultat av simuleringen efter att användaren har förflyttat en av punktkällorna med hjälp av piltangenterna.}}
   		\label{fig:resultat2}
	\end{figure}

	\Section{Slutord}
		
		Det finns en anledning till att fluidsimuleringar blivit så populära: det är både logiskt och visuellt stimulerande, det finns många appliceringar, och Navier-Stokes ekvationer är fortfarande, 2014, ett av de olösta matematiska millenieproblemen.

		Att som studenter utforska och tillämpa dessa för att skapa denna applikation har varit roligt, utvecklande och bitvis också mycket utmanande. Om du som läsare vill göra något liknande, rekommenderar vi att läsa de referenser som använts under arbetets gång.

		Förutom referenserna på nästa sida vill vi även tacka Anna Lombardi och Ulf Sannemo för deras handledning under projektets gång.

	\newpage
	\begin{thebibliography}{9}
		\bibitem{GPUGems1}
		Mark J. Harris \emph{Fast Fluid Dynamics Simulation on the GPU, GPU Gems, sida 637, Chapter 38}, NVIDIA och Addison-Wesley 2004		
		\bibitem{OpenGLSuperBible}
		Graham Sellers, Richard S. Wright, Jr. och Nicholas Haemel, \emph{OpenGL Super Bible, Sixth Edition}, Addison-Wesley 2013
		\bibitem{Fedkiw}
		Ronald Fedkiw, Jos Stam och Henrik Wann Jensen, \emph{Visual Simulation of Smoke}, ACM SIGGRAPH 2001
	   \bibitem{GPUGems3}
	   Keenan Crane, Ignacio Llamas och Sarah Tariq \emph{Real-Time Simulation and Rendering of 3D Fluids, GPU Gems 3, Chapter 30, http://http.developer.nvidia.com/GPUGems3/gpugems3\_ch30.html}, NVIDIA 2007
	   \bibitem{Grasshopper}
	   Philip Rideout \emph{Simple Fluid Simulation, http://prideout.net/blog/?p=58}, The Little Grasshopper 2010, 2014-03-11
	\end{thebibliography}
		
	\newpage
	\appendix

	\Section{Bilaga}
	\setcounter{table}{0}
	\renewcommand{\thetable}{A\arabic{table}}

	\begin{table}[h]
	\begin{center}
	\caption{Lista över konstanter.}
	\label{tbl:konstanter}
	 	\begin{tabular}{| l | l |}
	 	\hline
			Konstant: & Värde: \\ \hline
			Tidssteg & 0.1 \\ \hline
			Lyftkraft:  $ \alpha $ & 0,0125 \\ \hline
			Lyftkraft: $ \beta $ & 1 \\ \hline
			Värmekällans temperatur vid start: $ T_{amb} $ & 20 \\ \hline
			Rummets temperatur vid start & 0 \\ \hline
			Jacobi:  $ \alpha $ & -100 \\ \hline
			Jacobi: $ \beta $ & 0,1\\ \hline
		\end{tabular}
	\end{center}
	\end{table}

	% bilagor, t.ex. källkod. En tom extrasida kommer att skrivas ut för
	% att få alla sidnummer att stämma
	\begin{appendices}
		%\appitem{Källkod}{0}
		%\appsubitem{\texttt{minfil.c}}{2}
		%\appsubitem{\texttt{minfil.h}}{1}
		%\appitem{En bilaga på 3 sidor}{3}
	\end{appendices}

\end{document}


% Lite information om hur man arbetar med LaTeX
%-----------------------------------------------
%
% LaTeX-koden kan skrivas med en godtycklig editor.
% För att "kompilera" dokumentet används kommandot latex:
%    bergner@peppar:~/edu/sysprog/lab1> latex rapportmall.tex
% Resultatet blir ett antal filer, bl.a. en som heter rapportmall.dvi.
% Denna fil kan användas för att titta hur dokumentet egentligen ser
% ut med hjälp av programmet xdvi:
%    bergner@peppar:~/edu/sysprog/lab1> xdvi rapportmall.dvi &
% Du får då upp ett fönster som visar ditt dokument. Detta fönster
% kommer automatiskt att uppdateras då du ändrar och kompilerar om din
% LaTeX-kod. 
% När du anser att din rapport är färdig att skrivas ut använder man
% lämpligtvis kommandona dvips och lpr:
%    bergner@peppar:~/edu/sysprog/lab1> dvips -P ma436ps rapportmall.dvi
% Om man vill ha kvar PostScript-filen som dvips genererar kan man göra:
%    bergner@peppar:~/edu/sysprog/lab1> dvips -o rapport.ps rapportmall.dvi
%    bergner@peppar:~/edu/sysprog/lab1> lpr -P ma436ps rapport.ps
% OBS!!! För att innehållsförteckningen och eventuella referenser till
% tabeller och figurer garanterat ska stämma måste man köra latex 2ggr
% på sitt dokument efter att man har ändrat något.
%
%
% Lite information om saker man kan tänkas behöva i sitt arbete med LaTeX
%-------------------------------------------------------------------------
%
% FORMATTERA TEXT
%
% För att formattera text på lite olika sätt kan man använda följande LaTeX-
% kommandon:
%    \textbf{denna text kommer att vara i fetstil}
%    \emph{denna text är viktig (kursiv stil)}
%    \texttt{i denna text blir alla tecken lika breda, som med en skrivmaskin}
%    \textsf{denna text visas med ett typsnitt utan serifer}
%
%
% MATEMATISKA FORMLER
%
% För att typsätta matematiska formler kan man använda:
%    $f(x) = x^2 - 3$, vilket lägger in formeln i texten, eller
%    \begin{displaymath}
%        g(x) = \frac{\sin x}{x}
%    \end{displaymath}, vilket låter formeln visas centrerat på en egen rad
% Om du vill att en formel ska numreras byter du ut displaymath mot equation.
% Det finns massor med matematiska symboler, vilket gör att man behöver
% någon liten manual att titta i om man ska konstruera avancerade formler.
% Se slutet på filen för lite råd om var du kan hitta sådana.
%
%
% INFOGA FIGURER
%
% För att infoga en figur kan man göra på följande sätt:
%    \begin{figure}[htb]
%        \includegraphics[scale=0.5, angle=90]{exec_flow.eps}
%        \caption{Detta är bildtexten}
%        \label{EXECFLOW}
%    \end{figure}
% Om man vill referera till denna bild i texten skulle man då skriva enligt:
%    ...i figur \ref{EXECFLOW} kan man se att...
% Några små förklaringar till figurer:
%    [htb] = talar om hur latex ska försöka placera bilden (Here, Top, Bottom)
%            Om du använder [!h], innebär det Here!!!
%    scale = kan skala om bilden, om den är skalbar
%    angle = kan rotera bilden
%    exec_flow.eps = filnamnet på bilden. Notera att formatet .EPS används
% För att skapa figurer används lämpligtvis programmet xfig:
%    bergner@peppar:~/edu/sysprog/lab1> xfig &
% Rita (och spara ofta) tills du är klar. Välj sedan "Export" och exportera
% din figur till EPS-format.
% Om man vill kan man använda endast \includegraphics, men det är inte ofta
% man gör det.
%
%
% INFOGA TABELLER
%
% Om man vill skapa en tabell gör man på följande sätt:
%    \begin{table}[htb]
%        \begin{tabular}{|rlp{10cm}|}
%            \hline
%            13 & $17.26$ & En kommentar som kan sträcka sig över flera rader \\
%            \hline
%        \end{tabular}
%        \caption{Tabelltexten...}
%        \label{TBL:MINTABELL}
%    \end{table}
% Om man vill kan man endast använda raderna 2-6, dvs få en tabell utan text
% och nummer. Om man gör på detta vis kommer tabellen alltid att läggas på
% det ställe den skrivs i koden, dvs ungefär samma sak som [!h] -> Here!!!
% Några förklaringar:
%    l, r, c = vänsterjustera, högerjustera eller centrera kolumn
%    p{bredd} = skapa en vänsterjusterad kolumn med en viss bredd
%               kan innehålla flera rader text
%    | = en vertikal linje i tabellen
%    \hline = en horisontell linje i tabellen
%    & = kolumnseparator
%    \\ = radseparator
% Tänk på att tabeller oftast ser bättre ut med ganska få linjer.
%
%
% INFOGA KÄLLKOD ELLER UTDATA FRÅN TESTKÖRNINGAR
%
% Om man vill infoga källkod eller något annat liknande, t.ex. utdata från
% en testkörning är det bra om LaTeX återger utdatan korrekt, dvs en radbrytning
% betyder en radbrytning och 8 mellanslag på rad betyder 8 mellanslag på rad.
% För att åstadkomma detta används:
%    \begin{verbatim}
%        allt som skrivs här återges exakt, med skrivmaskinstypsnitt
%    \end{verbatim}
% Oftast finns det dock bättre verktyg för att skriva ut källkod. Exempel på
% sådana är a2ps, enscript och atp.
%
%
% ÄNDRA STORLEK PÅ TEXT
%
% Om du vill ändra storleken på ett stycke, t.ex. på din nyss infogade
% testkörning omger du stycket med \begin{STORLEK} \end{STORLEK}, där
% STORLEK är någon av:
%    tiny, scriptsize, footnotesize, small, normalsize, large, Large,
%    LARGE, huge, Huge
% Tänk på att inte mixtra för mycket med storlekar bara.
%
%
% SKAPA LISTOR AV OLIKA SLAG
%
% Det är ganska vanligt att man vill rada upp saker på något sätt. För att
% skapa punktlistor används:
%    \begin{itemize}
%        \item Detta är första punkten
%        \item Detta är andra punkten
%    \end{itemize}
% Om man istället vill ha en numrerad lista kan man använda enumerate istället
% för itemize. Listor kan användas i flera nivåer
%
%
% MER INFORMATION OM LaTeX
%
% Lite blandad information om LaTeX, länkar och annat hittar du på
% http://www.cs.umu.se/~bergner/latex.htm
% En del information om rapportskrivning hittar du på
% http://www.cs.umu.se/~bergner/rapport/
% Det finns massor med information om LaTeX på Internet. Ett litet urval:
% http://www.giss.nasa.gov/latex/
%     är en mycket välfylld sida om LaTeX
% http://wwwinfo.cern.ch/asdoc/WWW/essential/essential.html
%     är en manual som genererats utifrån ett LaTeX-dokument mha latex2html
% http://tex.loria.fr/english/
%     är ett fylligt arkiv av länkar till LaTeX-dokument på Internet
%
% Min personliga favorit är dock manualen "The Not So Short Introduction to
% LaTeX2e", som finns i DVI-format på ~bergner/LaTeX/lshort2e.dvi
% Där står i princip allt man behöver veta. Det är bara att använda xdvi och
% titta efter det du söker, vilket oftast finns där.
% Om du, precis som jag, vill kunna leka med många kommandon i LaTeX finns en
% "LaTeX Command Summary" på ~bergner/LaTeX/latexcmds.ps
