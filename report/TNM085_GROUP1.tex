%______________________________________________________
%
%   LaTeX-mall för nybörjare
%
%   Konstruerad av Marcus Bergner, bergner@cs.umu.se
%
%   Vid funderingar titta längst ned i denna fil,
%   eller skicka ett mail
%______________________________________________________
%

% lite inställningar
\documentclass[10pt, titlepage, oneside, a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage[swedish]{babel}
\usepackage{amssymb, graphicx, fancyheadings}
\usepackage{graphicx}
\usepackage{listings}
% Ursäkta lite bloat men det behövs för att få highlighting på GLSL
\lstdefinelanguage{GLSL}
{
sensitive=true,
morekeywords=[1]{
attribute, const, uniform, varying,
layout, centroid, flat, smooth,
noperspective, break, continue, do,
for, while, switch, case, default, if,
else, in, out, inout, float, int, void,
bool, true, false, invariant, discard,
return, mat2, mat3, mat4, mat2x2, mat2x3,
mat2x4, mat3x2, mat3x3, mat3x4, mat4x2,
mat4x3, mat4x4, vec2, vec3, vec4, ivec2,
ivec3, ivec4, bvec2, bvec3, bvec4, uint,
uvec2, uvec3, uvec4, lowp, mediump, highp,
precision, sampler1D, sampler2D, sampler3D,
samplerCube, sampler1DShadow,
sampler2DShadow, samplerCubeShadow,
sampler1DArray, sampler2DArray,
sampler1DArrayShadow, sampler2DArrayShadow,
isampler1D, isampler2D, isampler3D,
isamplerCube, isampler1DArray,
isampler2DArray, usampler1D, usampler2D,
usampler3D, usamplerCube, usampler1DArray,
usampler2DArray, sampler2DRect,
sampler2DRectShadow, isampler2DRect,
usampler2DRect, samplerBuffer,
isamplerBuffer, usamplerBuffer, sampler2DMS,
isampler2DMS, usampler2DMS,
sampler2DMSArray, isampler2DMSArray,
usampler2DMSArray, struct},
morekeywords=[2]{
radians,degrees,sin,cos,tan,asin,acos,atan,
atan,sinh,cosh,tanh,asinh,acosh,atanh,pow,
exp,log,exp2,log2,sqrt,inversesqrt,abs,sign,
floor,trunc,round,roundEven,ceil,fract,mod,modf,
min,max,clamp,mix,step,smoothstep,isnan,isinf,
floatBitsToInt,floatBitsToUint,intBitsToFloat,
uintBitsToFloat,length,distance,dot,cross,
normalize,faceforward,reflect,refract,
matrixCompMult,outerProduct,transpose,
determinant,inverse,lessThan,lessThanEqual,
greaterThan,greaterThanEqual,equal,notEqual,
any,all,not,textureSize,texture,textureProj,
textureLod,textureOffset,texelFetch,
texelFetchOffset,textureProjOffset,
textureLodOffset,textureProjLod,
textureProjLodOffset,textureGrad,
textureGradOffset,textureProjGrad,
textureProjGradOffset,texture1D,texture1DProj,
texture1DProjLod,texture2D,texture2DProj,
texture2DLod,texture2DProjLod,texture3D,
texture3DProj,texture3DLod,texture3DProjLod,
textureCube,textureCubeLod,shadow1D,shadow2D,
shadow1DProj,shadow2DProj,shadow1DLod,
shadow2DLod,shadow1DProjLod,shadow2DProjLod,
dFdx,dFdy,fwidth,noise1,noise2,noise3,noise4,
EmitVertex,EndPrimitive},
morekeywords=[3]{
gl_VertexID,gl_InstanceID,gl_Position,
gl_PointSize,gl_ClipDistance,gl_PerVertex,
gl_Layer,gl_ClipVertex,gl_FragCoord,
gl_FrontFacing,gl_ClipDistance,gl_FragColor,
gl_FragData,gl_MaxDrawBuffers,gl_FragDepth,
gl_PointCoord,gl_PrimitiveID,
gl_MaxVertexAttribs,gl_MaxVertexUniformComponents,
gl_MaxVaryingFloats,gl_MaxVaryingComponents,
gl_MaxVertexOutputComponents,
gl_MaxGeometryInputComponents,
gl_MaxGeometryOutputComponents,
gl_MaxFragmentInputComponents,
gl_MaxVertexTextureImageUnits,
gl_MaxCombinedTextureImageUnits,
gl_MaxTextureImageUnits,
gl_MaxFragmentUniformComponents,
gl_MaxDrawBuffers,gl_MaxClipDistances,
gl_MaxGeometryTextureImageUnits,
gl_MaxGeometryOutputVertices,
gl_MaxGeometryOutputVertices,
gl_MaxGeometryTotalOutputComponents,
gl_MaxGeometryUniformComponents,
gl_MaxGeometryVaryingComponents,gl_DepthRange},
morecomment=[l]{//},
morecomment=[s]{/*}{*/},
morecomment=[l][keywordstyle4]{\#},
}
\addtolength{\textheight}{20mm}
\addtolength{\voffset}{-5mm}
\renewcommand{\sectionmark}[1]{\markleft{#1}}

% \Section ger mindre spillutrymme, använd dem om du vill
\newcommand{\Section}[1]{\section{#1}\vspace{-8pt}}
\newcommand{\Subsection}[1]{\vspace{-4pt}\subsection{#1}\vspace{-8pt}}
\newcommand{\Subsubsection}[1]{\vspace{-4pt}\subsubsection{#1}\vspace{-8pt}}
	
% appendices, \appitem och \appsubitem är för bilagor
\newcounter{appendixpage}

\newenvironment{appendices}{
	\setcounter{appendixpage}{\arabic{page}}
	\stepcounter{appendixpage}
}{
}

\newcommand{\appitem}[2]{
	\stepcounter{section}
	\addtocontents{toc}{\protect\contentsline{section}{\numberline{\Alph{section}}#1}{\arabic{appendixpage}}}
	\addtocounter{appendixpage}{#2}
}

\newcommand{\appsubitem}[2]{
	\stepcounter{subsection}
	\addtocontents{toc}{\protect\contentsline{subsection}{\numberline{\Alph{section}.\arabic{subsection}}#1}{\arabic{appendixpage}}}
	\addtocounter{appendixpage}{#2}
}

% Ändra de rader som behöver ändras
\def\inst{teknik och naturvetenskap}
\def\typeofdoc{Projektrapport}
\def\course{Modelleringsprojekt}
%\def\pretitle{Laboration 1}
\def\title{Elements}
\def\name{\\ Niklas Andersson, nikan278 \\
Gabriel Baravdish, gabba873 \\
Joakim Deborg, joade361 \\
Kristofer Janukiewicz, krija286 \\
Marcus Nygren, marny568}
\def\username{c00abc}
%\def\email{\username{}@cs.umu.se}
%\def\path{edu/KURS/lab1}
\def\graders{Anna Lombardi, Ulf Sannemo}


% om du vill referera till katalogen där dina filer ligger kan du 
% använda \fullpath som kommer att vara "~username/edu..." o.s.v.
\def\fullpath{\raisebox{1pt}{$\scriptstyle \sim$}\username/\path}


% Här börjar själva dokumentet
\begin{document}

	% skapar framsidan (om den inte duger: gör helt enkelt en egen)
	\begin{titlepage}
		\thispagestyle{empty}
		\begin{large}
			\begin{tabular}{@{}p{\textwidth}@{}}
				\textbf{LINKÖPINGS UNIVERSITET \hfill \today} \\
				\textbf{Institutionen för \inst} \\
				\textbf{\typeofdoc} \\
			\end{tabular}
		\end{large}
		\vspace{10mm}
		\begin{center}
			%\LARGE{\pretitle} \\
			\huge{\textbf{\course}}\\
			\vspace{10mm}
			\LARGE{\title} \\
			\vspace{15mm}
			\begin{large}
				\begin{tabular}{ll}
					\textbf{Namn} & \name \\
					%\textbf{E-mail} & \texttt{\email} \\
					%\textbf{Sökväg} & \texttt{\fullpath} \\
				\end{tabular}
			\end{large}
			\vfill
			\large{\textbf{Handledare}}\\
			\mbox{\large{\graders}}
		\end{center}
	\end{titlepage}


	% fixar sidfot
	%\lfoot{\footnotesize{\name, \email}}
	\rfoot{\footnotesize{\today}}
	\lhead{\sc\footnotesize\title}
	\rhead{\nouppercase{\sc\footnotesize\leftmark}}
	\pagestyle{fancy}
	\renewcommand{\headrulewidth}{0.2pt}
	\renewcommand{\footrulewidth}{0.2pt}

	%Skapa sammanfattning
	\begin{abstract}
	This is the paper's abstract. This is the paper's abstract.This is the paper's abstract.This is the paper's abstract.This is the paper's abstract.This is the paper's abstract.This is the paper's abstract. This is the paper's abstract.This is the paper's abstract.This is the paper's abstract.This is the paper's abstract.This is the paper's abstract.
	\end{abstract}
	
	% skapar innehållsförteckning.
	% Tänk på att köra latex 2ggr för att uppdatera allt
	\pagenumbering{roman}
	\tableofcontents
	
	% och lägger in en sidbrytning
	\newpage

	\pagenumbering{arabic}

	% i Sverige har vi normalt inget indrag vid nytt stycke
	\setlength{\parindent}{0pt}
	% men däremot lite mellanrum
	\setlength{\parskip}{10pt}

	\Section{Introduktion}
		Elements är en programvara som utför fluid-simuleringar baserade på Navier-Stokes ekvationer. Programmet visar i dagsläget endast rök, men systemet är utformat för att i framtiden kunna byggas ut med eld och vatten samt ökad funktionalitet. Visionen med Elements är att användaren ska kunna utforska Navier-Stokes ekvationer med hjälp av att experimentera med olika interaktiva realtidssimuleringar.

		Målet med projektet har varit att utmanas tekniskt, kombinera medieteknik och datateknik, erfara modellering och simulering, och genom projektet bidra till ökad kunskap hos andra.
	
		
	\Section{Fysikalisk beskrivning}

	<Sammanfattning av samtliga steg/viktiga punkter nedan, ge snabb överblick>
	
	\Subsection{Förklaring av Navier-Stokes ekvationer}
		Navier-Stokes ekvationer, se ekvation $ \ref{eq:Navier-Stokes} $ och $ \ref{eq:Konservering av massa} $, som modellerar en fluid ser på fluiden som en kontinuerlig substans där hela volymen studeras. Ekvationerna i sig bygger på konservering av massa, rörelsemängd och energi och härstammar från ett antal volym- och yt-integraler över en godtycklig volym, se Reynolds Transport Theorem (RTT), ekvation $ \ref{eq:Reynolds Transport Theorem} $. RTT säger att summan av en fysisk egenskap, $ \psi  $, definerad på volymen $ \Omega $ måste vara lika med vad som är förändrat genom randen till $ \Omega $ plus vad som är förändrat innuti $ \Omega $ genom eventuella källor och sänkor.
	
	\begin{center}
		\begin{equation}\label{eq:Navier-Stokes}
			\bold \varrho \left ( \frac{\partial }{\partial t} \bold u + \bold u \cdot \nabla \bold u \right ) 
			= 
			- \nabla p
			+ \nabla \cdot \bold \Gamma + \bold f
		\end{equation}	
		
		\begin{equation}\label{eq:Konservering av massa}
		 	\nabla \cdot \bold u = 0 
		\end{equation}
	\end{center}

	\begin{center}
		\begin{equation}\label{eq:Reynolds Transport Theorem}
			\frac{\partial }{\partial t}\int_{\Omega}^{ } \psi\ \mathrm{d}V 
			= 
			- \int_{\partial\Omega}^{ } \psi \bold u \cdot \bold n \ \mathrm{d}A 
			- \int_{\Omega}^{ } \chi \ \mathrm{d}V
		\end{equation}
	\end{center}
	
	\begin{center}
		\begin{equation}\label{eq:Reynolds Transport Theorem 2}
			\frac{\partial }{\partial t}\int_{\Omega}^{ } \psi\ \mathrm{d}V 
			= 
			- \int_{\Omega}^{ } \nabla \cdot \left (  \psi \bold u \right ) \mathrm{d}V
			- \int_{\Omega}^{ } \chi   \ \mathrm{d} V
		\end{equation}
	\end{center}
	
	Leibniz lag säger att vi kan flytta in derivatan.
	\begin{center}
		\begin{equation}\label{eq:Reynolds Transport Theorem 3}
			\int_{\Omega}^{ } \frac{\partial }{\partial t} \psi\ \mathrm{d}V
			+ \int_{\Omega}^{ } \nabla \cdot \left (  \psi \bold u \right ) \mathrm{d}V
			+ \int_{\Omega}^{ } \chi   \ \mathrm{d} V
			=
			0
		\end{equation}
	\end{center}
	
	\begin{center}
		\begin{equation}\label{eq:Reynolds Transport Theorem Leibniz}
			\int_{\Omega}^{ } \left ( \frac{  \partial }{\partial t} \psi\ 
			+ \nabla \cdot \left (  \psi \bold u \right ) 
			+ \chi  \right ) \mathrm{d}V
			= 
			0
		\end{equation}
	\end{center}
	
	Eftersom integralen i ekvation $ \ref{eq:Reynolds Transport Theorem Leibniz} $ ska vara lika med noll för alla volymer $ \Omega $ erhålls $ \ref{eq:Reynolds Transport Theorem Leibniz 2} $.
	
	\begin{center}
		\begin{equation}\label{eq:Reynolds Transport Theorem Leibniz 2}
			\frac{  \partial }{\partial t} \psi\ 
			+ \nabla \cdot \left (  \psi \bold u \right ) 
			+ \chi 
			= 
			0
		\end{equation}
	\end{center}
	
	
	\Subsection{Konservering av massa}
	Här är $ \psi = \varrho $ och då det inte finns några källor eller sänkor av massa blir $ \chi  $ lika med noll, detta i enlighet med ekvation $ \ref{eq:Konservering av massa 1} $.
	
	\begin{center}
		\begin{equation}\label{eq:Konservering av massa 1}
			\frac{  \partial }{\partial t} \varrho \ 
			+ \nabla \cdot \left (  \varrho \bold u \right ) 
			= 
			0
		\end{equation}
	\end{center}
	
	Om $ \varrho $ fixeras till en konstant leder det till att $ \frac{  \partial }{\partial t} \varrho \  = 0 $ och att $ \nabla \cdot \left (  \varrho \bold u \right ) = 0 $. Det senare villkoret leder fram till sambandet om konserverandet av massa, ekvation $ \ref{eq:Konservering av massa} $, som ofta ackompinerar Navier-Stokes ekvation, $ \ref{eq:Navier-Stokes} $. Sambandet innebär att fluiden är inkompressibel, det vill säga att fluiden alltid behåller sin ursprungliga volym.
	
	
	\Subsection{Konservering av rörelsemängd}
	Från rörelsemängd, $ p = m\bold u $, fås att $ \psi = \varrho \bold u $, vilket ger ekvation $ \ref{eq:Konservering av rörelsemängd} $.
	
	\begin{center}
		\begin{equation}\label{eq:Konservering av rörelsemängd}
			\frac{  \partial }{\partial t} \varrho \bold u \ 
			+ \nabla \cdot \left ( \varrho \bold u  \bold u \right ) 
			+ \chi 
			= 
			0
		\end{equation}
	\end{center}
	
	Utveckling av ekvation $ \ref{eq:Konservering av rörelsemängd} $ ger ekvation $ \ref{eq:Konservering av rörelsemängd 2} $, där $ \bold b $ representerar en källa eller sänka. 
	
	\begin{center}
		\begin{equation}\label{eq:Konservering av rörelsemängd 2}
			\bold u \frac{  \partial }{\partial t} \varrho \ 
			+ \varrho \frac{  \partial }{\partial t} \bold u \ 
			+ \bold u  \bold u \  \cdot \nabla \varrho
			+ \varrho \bold u \cdot \nabla \bold u
			+ \varrho \bold u \nabla \cdot \bold u
			= \bold b
		\end{equation}
	\end{center}
		
	Ytterliggare omskrivning av ekvation $ \ref{eq:Konservering av rörelsemängd 2} $ ger ekvation $ \ref{eq:Konservering av rörelsemängd 3} $.
	
	\begin{center}
		\begin{equation}\label{eq:Konservering av rörelsemängd 3}
			\bold u \left ( \frac{  \partial }{\partial t} \varrho + \bold u \cdot \nabla \varrho + \varrho \nabla \cdot \bold u \right ) 
			+ \varrho \left ( \frac{  \partial }{\partial t} \bold u 
			+ \bold u \cdot \nabla \bold u \right )
			= \bold b
		\end{equation}
	\end{center}
	
	I ekvation $ \ref{eq:Konservering av rörelsemängd 3} $ innehåller den första termen sambandet om konservering av massa, ekvation $ \ref{eq:Konservering av massa 1} $, då
	$ \bold u \cdot \nabla \varrho + \varrho \nabla \cdot \bold u 
	= \nabla \cdot \left ( \varrho \bold u \right ) $. Detta medför att denna term måste vara lika med noll, vilket innebär att kvar blir ekvation $ \ref{eq:Konservering av rörelsemängd 4} $.
	
	\begin{center}
		\begin{equation}\label{eq:Konservering av rörelsemängd 4}
			 \varrho \left ( \frac{  \partial }{\partial t} \bold u 
			+ \bold u \cdot \nabla \bold u \right )
			= \bold b
		\end{equation}
	\end{center}
	
	Utveckling av ekvation $ \ref{eq:Konservering av rörelsemängd 4} $ ger ett samband som kan knytas till Newtons andra lag, $ \bold F = m \bold a $, se ekvation  $ \ref{eq:Konservering av rörelsemängd 5} $ och $ \ref{eq:Konservering av rörelsemängd 6} $, där $ \varrho $ representerar massan $ m $, $ \bold b $ yttre krafter $ \bold F $ och där materialderivatan för $ \bold u $ representerar accelerationen $ \bold a $. $ \sigma $ är Cauchys spänningstensor och kan förenklas till $ \sigma = -pI +  \bold \Gamma \ $, där $ p $ är tryck, $ I $ är identitesmatrisen, 
	
	\begin{center}
		\begin{equation}\label{eq:Konservering av rörelsemängd 5}
			\varrho \left ( 
			\frac{\partial \bold u }{\partial t}
			+  u _{x} \frac{\partial u _{x}} {\partial x} 
			+  u _{y} \frac{\partial u _{y}} {\partial y} 
			+  u _{z} \frac{\partial u _{z}} {\partial z} 
			\right )
			=
			\bold b
		\end{equation}
	\end{center}

	\begin{center}
		\begin{equation}\label{eq:Konservering av rörelsemängd 6}
			\varrho \
			\frac{\partial }{\partial t} 
			\bold u(x,y,z,t)
			=
			\bold b
		\end{equation}
	\end{center}
	
	Genom att studera en voxel i en fluid fås att kraften $ \bold b $ kan delas upp i två termer engligt $ \bold b =   \nabla \cdot \sigma + \bold f $, där $ \nabla \cdot \sigma $ härstammar från tryck och där $ \bold f $ härstammar från yttre krafter.
		
		
	\Subsection{Konservering av energi}
	
	\Subsection{Val av beräkningsmetod}
	
	Det finns två olika sätt att basera sina beräkningar på, det Euleriska synsättet och det Lagrageiska synsättet. Det Lagrangeiska synsättet ser kontinuumet som ett partikelsystem, där en partikel kan likställas med en enskild molekyl. Till skillnad från det Lagrangeiska synsättet där enskilda partiklar studeras, bygger inte det Euleriska synsättet på att fixerade punkter i rummet studeras. Fluidens egenskaper som exempelvis hastighet, densitet, temperatur, beräknas i varje given punkt.

	Vid fluid-simuleringar på GPU lämpar det sig bäst att använda sig av det Euleriska synsättet, eftersom dem intressanta punkterna i rymden med fördel kan placeras i ett rutnät som direkt kan representeras av en textur. Således tillämpas det Euleriska synsättet i det här projektet.
	
		\Subsection{Modellering}
		\emph{Övergripande beskrivning kring modellerings implementationen i vårt projekt.}
		
		Modell för inkompressibel homogen fluid:		

	\Section{Numerisk implementation}

		
		\Subsection{Implementation av Navier-stokes ekvationer}
För implementaion av Navier-stokes ekvationerna förenklas 				systemet 	från ekvation $ \ref{eq:Navier-Stokes} $ till
	ekvation $ \ref{eq:Navier-stokes simple} $
	\\
	\\
		Mer teori och bakgrund finns hämta  i <Nvidia referens>.

	\begin{center}
		\begin{equation}\label{eq:Navier-stokes simple}
			\frac{du}{dt}= -(\bold u \cdot \nabla \bold u) - \frac{1}{ \rho } 				\nabla p + \bold f
		\end{equation}
	\end{center}
	
	Tillsammans med villkoret:
	\begin{center}
		\begin{equation}\label{eq:villkor}
			\nabla \cdot \bold u = 0
		\end{equation}
	\end{center}
	
	
	
	Ekvation $ \ref{eq:Navier-stokes simple} $ kan brytas ned och beräknas komponentvis. Där 
 	$ \bold u \cdot \nabla \bold u $ beskriver 	förflyttningen av hastigheten, $ \nabla p $  tryckförändringen i rummet och $\bold f $ är en lämplig extern kraft för simulering av rök. För varje komponent uppdateras rutnätet tills alla komponenter har beräknats och därefter påbörjas en ny beräkning.
	
	Den första komponenten som beräknas är förflyttningen. Förlyttning av en fysikalisk kvantitet kan beräknas numerisk med olika metoder. En användbar stegmetod för fluider är Eulers implicita stegmetod. Då Eulers explicita metod tenderar att ge okontrollerbar ökning av felet så är den implicita metoden stabil för vissa valda tidssteg och enkel att implementera på GPU:n. Förflyttningen sker genom att spåra kvantiteten bakåt i tiden, därefter beräknas en billinjär interpolation på dem fyra närliggande värdena i rutnätet.


	När förflyttning har genomförts beräknas den andra komponenten, trycket. Trycket beräknas genom att först skapa en vektor $w$ enligt ekvation  $ \ref{eq:vektor w} $
	\begin{center}
		\begin{equation}\label{eq:vektor w}
			\bold w = \bold u + \nabla p
		\end{equation}
	\end{center}
	
	Därefter appliceras divergensoperatorn på ekvation $ \ref{eq:vektor w} $ och tillsammans med villkoret $ \ref{eq:villkor} $ blir resultatet $ \ref{eq:Poissons ekvation} $, Poissons ekvation.
	
	\begin{center}
		\begin{equation}\label{eq:Poissons ekvation}
			\nabla ^2 p = \nabla \cdot \bold w 
		\end{equation}
	\end{center}
	
	I ekvation $ \ref{eq:Poissons ekvation} $ står $\bold w$ för hastigheten som hittills räknats ut av dem tidigare komponenterna i ekvationen, alltså inte samma hastighet som är divergenslös i villkoret i ekvation $ \ref{eq:villkor} $. Poissons ekvation kan skrivas om till matrisform, $ \bold A \bold x = \bold b $, där $\bold A $ är byggd från laplacianen, $ \bold b $ är konstanter från $ \bold w $ och $ \bold x $ är den sökta vektorn. Metoden som används för att lösa systemet är Jacobis iterativa metod. Det innebär att metoden först kräver en gissad lösning och för att den sedan ska kunna iterera en förbättrad lösning för varje steg som tas. Processen är iterativ tills lösningen konvergerar. Det finns olika numeriska metoder till att lösa Poissons ekvation, men tack vare Jacobis enkla struktur utförs beräkningarna snabbt på GPU:n, även om metoden konvergerar långsammare än andra metoder.

Slutligen uppdateras hastigheten med externa krafter. Det finns olika externa krafter som verkar på rök. Men för enkelhetens skull har bara en kraft tagits med i implementationen, rökens lyftkraft. Det är en kraft som återfinns i verkliga sammanhang och som beror av temperaturen i rummet och gasens densitet. Temperatur- och densitetsförändringen ges av ekvationerna $ \ref{eq:Temperatur} $ respektive $ \ref{eq:Densitet} $

	\begin{center}
		\begin{equation}\label{eq:Temperatur}
			\frac{\partial T}{\partial t} = -(\bold u \cdot \nabla)T,			
		\end{equation}
	\end{center}
	\begin{center}
		\begin{equation}\label{eq:Densitet}
			\frac{\partial \rho}{\partial t} = -(\bold u \cdot \nabla)\rho.	 
		\end{equation}
	\end{center}

	Från ekvation $\ref{eq:Navier-stokes simple}$ kan den externa kraften, $ \bold f$, beräknas genom ekvation $\ref{eq:Buoyancy}$.
	\begin{center}
		\begin{equation}\label{eq:Buoyancy}
			\bold f_{buoy} = - \alpha\rho\bold z + \beta(T-T_{amb})\bold z	 
		\end{equation}
	\end{center}




		\Subsection{Matlab}
		\emph{Allt vi gjort i Matlab och vad vi kom fram till med hjälp av detta. Varför använde vi Matlab? Fanns det andra metoder att gå tillväga? Hur fick vi över ekvationerna till Matlab?}

		\Subsection{OpenGL/GLSL}
		\Subsubsection{Introduktion}
		Realtidssimuleringar av fluider är mycket krävande även för dagens moderna datorer, vilket innebär att metoder för bättre prestanda är eftertraktade. En sådan teknik är att implementera den numeriska lösningen på GPU (istället för CPU), för att utnyttja möjligheten att köra beräkningarna parallellt. Även på moderna processorer är det möjligt att utföra beräkningar parallellt på fyra eller till och med åtta kärnor dock kan detta inte mäta sig med de upp emot 2500 beräkningskärnor som kan tillgås på ett nyare grafikkort.
		
		\Subsubsection{Metod}
		
		För GPU-implementationen användes programmeringsspråket C++ med grafikbiblioteket OpenGL för att styra programmet på applikationsnivå. För att komma närmare hårdvaran och kontrollera hur grafikkortet utförde beräkningarna användes även språket GLSL. 

		För att beskriva simuleringen behövdes att antal värden sparas för varje cell i volymen. Dessa värden kan intuitivt representeras som 3d-texturer med olika många komponenter per voxel (volymelement).  Till exempel så kan en hastighet i tre dimensioner lagras som en vektor med tre komponenter. För att spara en hastighet för varje cell i volymen användes en 3d-textur där varje voxel innehåller tre komponenter. För att bestämma hur många komponenter en textur skulle ha användes OpenGL-funktionen: 
\begin{lstlisting}[language=C++]
void glTexImage3D(GLenum target,
 	GLint level,
 	GLint internalFormat,
 	GLsizei width,
 	GLsizei height,
 	GLsizei depth,
 	GLint border,
 	GLenum format,
 	GLenum type,
 	const GLvoid * data);
\end{lstlisting}
De parametrar som kontrollerar antalet komponenter är internalFormat och format. Nedan visas en tabell över de texturer som användes, hur många komponenter de hade och vilka värden som användes på de ovan nämnda parametrarna.

\begin{center}
	 \begin{tabular}{| l | l | l | l |}
	 \hline
		Storhet & Komponenter & internalFormat & format \\ \hline
		Hastighet & 3 & GL\_RGB16F & GL\_RGB \\ \hline
		Densitet & 3 & GL\_RGB16F & GL\_RGB \\ \hline
		Tryck & 1 & GL\_R16F & GL\_RED \\ \hline
		Divergens & 3 & GL\_RGB16F & GL\_RGB \\ \hline
		Temperatur & 1 & GL\_R16F & GL\_RED \\ \hline
	\end{tabular}
\end{center}
För en mer omfattande beskrivning av hur texturer skapas i OpenGL se \cite[s.~138]{OpenGLSuperBible}. \\

		
	\Section{Grafisk implementation}

		\Subsection{OpenGL}
		\emph{Varför valde vi OpenGL? Hur fick vi fram renderingen på skärmen?}
		
		\Subsection{Qt}
För att utveckla och skapa ett användagränssnitt i C++ rekommenderas ofta Qt. Det är ett populärt multiplattformsbibliotek för att utveckla GUI:n, med ett egenutvecklat designskriptspråk, QML. Detta språket kommunicerar med C++ via en metod kallad “Signals \& Slots” och kan även hantera JavaScript-funktioner.

		Det upptäcktes dock att medan Qt lämpar sig väldigt väl för att göra ett avancerat GUI, vilket var ett av projektens önskemål, lämpar sig inte biblioteket för att göra avancerad 3D i OpenGL, främst därför att Qt styr över i vilken ordning olika operationer ska utföras, vilket kan vara en försvårande omständighet i mer avancerade grafikapplikationer.

		Inom projektet utvecklades fortfarande ett fungerande GUI som visade på funktionaliteten att användaren via interaktion med till exempel knappar kan kommunicera med C++-lagret. Tyvärr används inte denna implementation alls i resultatet av projektet, då vårt slutgiltiga bibliotek GLFW och Qt inte är kompatibla med varandra. Det skulle vara möjligt att använda Qt, förutsatt att man i början av projektet lägger mycket tid på att abstrahera C++-applikationen och Qt-gränssnittet, och anpassar sig efter de förutsättningar som finns.
				

%		\begin{figure}[ht!]
%			\centering
%			\includegraphics[width=90mm]{QtGui}
%			\caption{Användargränsnittet skapat i Qt som inte kom med till slutresultatet}
%			\label{QtGui}
%		\end{figure}
		
		\Subsection{GLFW}
		
		\Subsection{Introduktion}
		GLFW är ett plattformsoberoende fönsterhanterings-ramverk utan onödiga finesser. GLFW har inte något inbyggt stöd för att göra GUI, men är ett mycket uppskattat ramverk bland utvecklare för att utveckla prestandatunga applikationer i OpenGL. Det som GLFW kan sköta är fönsterhantering och inmatning från bland annat mus och tangentbord.
		
		\Subsection{Metod}
		När GLFW används vid utveckling av en OpenGL-applikationer behövs först ett annat ramverk för att ladda de OpenGL-funktioner som finns tillgängliga på systemet. För detta ändamål användes GLEW. I den här rapporten kommer inte GLEW att beskrivas i detalj. Det finns många bibliotek med samma funktionalitet och valet mellan dessa spelar inte någon större roll.

		Resultatet från den numeriska lösningen är en 3d-textur som innehåller diskreta värden för densitetens utbredning i fluiden. 3d-texturen visualiseras genom att ett 2d-plan plockas ut vid ett diskret z-värde i mitten av volymen för att sedan mappas till en quad som täcker hela viewporten. Detta görs genom att rendera två trianglar som tillsammans bildar en rektangel och fyller hela skärmen. Hörnpunkterna skickas sedan till en vertex-shader som inte utför några beräkningar utan endast skickar den vidare. Det är först när de enskilda fragmenten ska behandlas som något meningsfullt sker. Här behandlas varje fragment av en fragment-shader som hämtar ett värde ur den bundna 3d-texturen beroende på fragmentets koordinater samt vilken nivå i z-led som ska visas. Viktigt att notera är att fragmentets koordinater antar värden mellan noll och fönstretsstorlek medan texturkoordinater ges mellan noll och ett. Det är alltså nödvändigt för fragment-shadern att veta om fönstret storlek så att koordinaterna kan normaliseras. Fragment-shadern syns nedan:

\begin{lstlisting}[language=GLSL]
out vec3 color;
uniform sampler3D tex;
uniform float layer;
uniform vec3 dimensions;
uniform vec2 windowSize;

void main()
{
  color = texture(tex, vec3(gl_FragCoord.x / windowSize.x ,
  gl_FragCoord.y / windowSize.y, layer/dimensions.z)).xyz;
}
\end{lstlisting} 


		\Subsection{Diskussion}
		Den ovan nämnda metoden för att visualisera innehållet i en 3d-textur användes för att den är mycket lätt att implementera, dock går en stor del av meningen med att utföra simuleringen i tre dimensioner förlorad. Ett mer tilltalande alternativ hade varit att visualisera hela volymen i tre dimensioner med hjälp av volymrendering. Detta hade dock krävt betydligt mer implementation, vilket var utanför denna kurs ramar.
		Resultat
		
		Nedan visas resultatet av att rendera ett lager av 3d-texturen som innehåller densitetens utbredning. De olika punktkällorna har olika densitet, där röken efter en tid breder ut sig och krockar med de cirkulära objekten. Implementationen tillåter en användare att styra den mittersta punktkällan.

		\Subsection{Resultat}
		I figur 1 visas resultatet av att rendera ett lager av 3d-texturen som innehåller densitetens utbredning. De olika punktkällorna har olika densitet, där röken efter en tid breder ut sig och krockar med de cirkulära objekten. Implementationen tillåter en användare att styra den mittersta punktkällan.

		<Lägg in resultat-bild här>
	
	\Section{Diskussion}
		
		Från början gick projektet ut på att utveckla ett gränssnitt i Qt där användaren grafiskt fick modifiera parametrarna och dess värden i Navier-Stokes, med syftet att ge användaren en väldigt pedagogisk koppling mellan ekvationerna och dess visuella representation.

		Om vi hade gjort om projektet hade vi utvecklat applikationen direkt i GLFW med tanke på att kursens tyngd låg i att utforma modellering och simulering, ej att producera en färdig produkt. Alldeles för sent i projektet upptäcktes varför det var så svårt att få en fungerande avancerad grafiska applikationer att fungera i Qt. Så fort projektet bytte fokus till GLFW gick det mycket snabbare att utveckla, även om det innebar att allt GUI-arbete varit förgäves.

		Med det sagt lämpar sig Qt fortfarande väl för tunga C++-applikationer som gynnas av användargräsnitt, men kraven på hur man utformar programvaran blir mycket högre och en kalkylerad avvägning rekommenderas. För utvecklingsteamet var det uppskattat att lära sig både i Qt och GLFW under en och samma projekt. Det har dock fått följden att gruppen inte kommit så långt som visionen varit i något av systemen - som flera olika fluider, större användarkontroll, 3d-representation, fler externa krafter representerade, etcetera. Resultatet bedöms ändå som framgångsrikt, då de kunskapsmässiga målen för kursen överträffats.

		Vi är väldigt nöjda med valet att göra applikationen GPU-baserad. Simuleringen kör i realtid, så det går att interagera med den via piltangenterna, vilket inte hade varit möjligt annars. 

	\Section{Resultat}
		\emph{Projektets resultat. Om man följer hela workflowen i metod-delen vart hamnar man då? Vad kom vi fram till?}
		
		TEXT..

	\Section{Slutsats}
		
		Det finns en anledning till att fluidsimuleringar blivit så populära: det är både logiskt och visuellt stimulerande, det finns många appliceringar, och Navier Stokes ekvationer är –fortfarande 2014– ett av de olösta matematiska millenieproblemen.

		Att som studenter utforska och tillämpa dessa för att skapa denna applikation har varit roligt, utvecklande och bitvis också väldigt utmanande. Om du som läsare vill göra något liknande, rekommenderar vi verkligen att se vilka referenser vi använt som grund för detta arbete. För matematisk teori och implementation av Navier-Stokes har vi främst använt <Nvidia-länk> som referens, för rök-implementation av Navier-Stokes har vi främst använt <Grasshopper-länk> och <Visual Simulation of Smoke-länk>.

		Förutom referenserna på nästa sida vill vi även tacka vår kurshandledare Anna Lombardi.

	\newpage
	\begin{thebibliography}{9}
		\bibitem{OpenGLSuperBible}
		Graham Sellers, Richard S. Wright, Jr. och Nicholas Haemel, \emph{OpenGL Super Bible, Sixth Edition}, Addison-Wesley 2013
		\bibitem{GPUGems1}
		Mark J. Harris \emph{Fast Fluid Dynamics Simulation on the GPU, GPU Gems, sida 637, Chapter 38}, NVIDIA och Addison-Wesley 2004
	   \bibitem{GPUGems3}
	   Keenan Crane, Ignacio Llamas och Sarah Tariq \emph{Real-Time Simulation and Rendering of 3D Fluids, GPU Gems 3, Chapter 30, http://http.developer.nvidia.com/GPUGems3/gpugems3\_ch30.html}, NVIDIA 2007
	   \bibitem{Grasshopper}
	   Philip Rideout \emph{Simple Fluid Simulation, http://prideout.net/blog/?p=58}, The Little Grasshopper 2010
	\end{thebibliography}
		
	\newpage
	\appendix

	\Section{Bilaga}
	\ldots{}här kan man lägga till bilagor
	
	\newpage
	\Section{Bilaga}
	\ldots{}här kan man lägga till bilagor

	% bilagor, t.ex. källkod. En tom extrasida kommer att skrivas ut för
	% att få alla sidnummer att stämma
	\begin{appendices}
		%\appitem{Källkod}{0}
		%\appsubitem{\texttt{minfil.c}}{2}
		%\appsubitem{\texttt{minfil.h}}{1}
		%\appitem{En bilaga på 3 sidor}{3}
	\end{appendices}

\end{document}


% Lite information om hur man arbetar med LaTeX
%-----------------------------------------------
%
% LaTeX-koden kan skrivas med en godtycklig editor.
% För att "kompilera" dokumentet används kommandot latex:
%    bergner@peppar:~/edu/sysprog/lab1> latex rapportmall.tex
% Resultatet blir ett antal filer, bl.a. en som heter rapportmall.dvi.
% Denna fil kan användas för att titta hur dokumentet egentligen ser
% ut med hjälp av programmet xdvi:
%    bergner@peppar:~/edu/sysprog/lab1> xdvi rapportmall.dvi &
% Du får då upp ett fönster som visar ditt dokument. Detta fönster
% kommer automatiskt att uppdateras då du ändrar och kompilerar om din
% LaTeX-kod. 
% När du anser att din rapport är färdig att skrivas ut använder man
% lämpligtvis kommandona dvips och lpr:
%    bergner@peppar:~/edu/sysprog/lab1> dvips -P ma436ps rapportmall.dvi
% Om man vill ha kvar PostScript-filen som dvips genererar kan man göra:
%    bergner@peppar:~/edu/sysprog/lab1> dvips -o rapport.ps rapportmall.dvi
%    bergner@peppar:~/edu/sysprog/lab1> lpr -P ma436ps rapport.ps
% OBS!!! För att innehållsförteckningen och eventuella referenser till
% tabeller och figurer garanterat ska stämma måste man köra latex 2ggr
% på sitt dokument efter att man har ändrat något.
%
%
% Lite information om saker man kan tänkas behöva i sitt arbete med LaTeX
%-------------------------------------------------------------------------
%
% FORMATTERA TEXT
%
% För att formattera text på lite olika sätt kan man använda följande LaTeX-
% kommandon:
%    \textbf{denna text kommer att vara i fetstil}
%    \emph{denna text är viktig (kursiv stil)}
%    \texttt{i denna text blir alla tecken lika breda, som med en skrivmaskin}
%    \textsf{denna text visas med ett typsnitt utan serifer}
%
%
% MATEMATISKA FORMLER
%
% För att typsätta matematiska formler kan man använda:
%    $f(x) = x^2 - 3$, vilket lägger in formeln i texten, eller
%    \begin{displaymath}
%        g(x) = \frac{\sin x}{x}
%    \end{displaymath}, vilket låter formeln visas centrerat på en egen rad
% Om du vill att en formel ska numreras byter du ut displaymath mot equation.
% Det finns massor med matematiska symboler, vilket gör att man behöver
% någon liten manual att titta i om man ska konstruera avancerade formler.
% Se slutet på filen för lite råd om var du kan hitta sådana.
%
%
% INFOGA FIGURER
%
% För att infoga en figur kan man göra på följande sätt:
%    \begin{figure}[htb]
%        \includegraphics[scale=0.5, angle=90]{exec_flow.eps}
%        \caption{Detta är bildtexten}
%        \label{EXECFLOW}
%    \end{figure}
% Om man vill referera till denna bild i texten skulle man då skriva enligt:
%    ...i figur \ref{EXECFLOW} kan man se att...
% Några små förklaringar till figurer:
%    [htb] = talar om hur latex ska försöka placera bilden (Here, Top, Bottom)
%            Om du använder [!h], innebär det Here!!!
%    scale = kan skala om bilden, om den är skalbar
%    angle = kan rotera bilden
%    exec_flow.eps = filnamnet på bilden. Notera att formatet .EPS används
% För att skapa figurer används lämpligtvis programmet xfig:
%    bergner@peppar:~/edu/sysprog/lab1> xfig &
% Rita (och spara ofta) tills du är klar. Välj sedan "Export" och exportera
% din figur till EPS-format.
% Om man vill kan man använda endast \includegraphics, men det är inte ofta
% man gör det.
%
%
% INFOGA TABELLER
%
% Om man vill skapa en tabell gör man på följande sätt:
%    \begin{table}[htb]
%        \begin{tabular}{|rlp{10cm}|}
%            \hline
%            13 & $17.26$ & En kommentar som kan sträcka sig över flera rader \\
%            \hline
%        \end{tabular}
%        \caption{Tabelltexten...}
%        \label{TBL:MINTABELL}
%    \end{table}
% Om man vill kan man endast använda raderna 2-6, dvs få en tabell utan text
% och nummer. Om man gör på detta vis kommer tabellen alltid att läggas på
% det ställe den skrivs i koden, dvs ungefär samma sak som [!h] -> Here!!!
% Några förklaringar:
%    l, r, c = vänsterjustera, högerjustera eller centrera kolumn
%    p{bredd} = skapa en vänsterjusterad kolumn med en viss bredd
%               kan innehålla flera rader text
%    | = en vertikal linje i tabellen
%    \hline = en horisontell linje i tabellen
%    & = kolumnseparator
%    \\ = radseparator
% Tänk på att tabeller oftast ser bättre ut med ganska få linjer.
%
%
% INFOGA KÄLLKOD ELLER UTDATA FRÅN TESTKÖRNINGAR
%
% Om man vill infoga källkod eller något annat liknande, t.ex. utdata från
% en testkörning är det bra om LaTeX återger utdatan korrekt, dvs en radbrytning
% betyder en radbrytning och 8 mellanslag på rad betyder 8 mellanslag på rad.
% För att åstadkomma detta används:
%    \begin{verbatim}
%        allt som skrivs här återges exakt, med skrivmaskinstypsnitt
%    \end{verbatim}
% Oftast finns det dock bättre verktyg för att skriva ut källkod. Exempel på
% sådana är a2ps, enscript och atp.
%
%
% ÄNDRA STORLEK PÅ TEXT
%
% Om du vill ändra storleken på ett stycke, t.ex. på din nyss infogade
% testkörning omger du stycket med \begin{STORLEK} \end{STORLEK}, där
% STORLEK är någon av:
%    tiny, scriptsize, footnotesize, small, normalsize, large, Large,
%    LARGE, huge, Huge
% Tänk på att inte mixtra för mycket med storlekar bara.
%
%
% SKAPA LISTOR AV OLIKA SLAG
%
% Det är ganska vanligt att man vill rada upp saker på något sätt. För att
% skapa punktlistor används:
%    \begin{itemize}
%        \item Detta är första punkten
%        \item Detta är andra punkten
%    \end{itemize}
% Om man istället vill ha en numrerad lista kan man använda enumerate istället
% för itemize. Listor kan användas i flera nivåer
%
%
% MER INFORMATION OM LaTeX
%
% Lite blandad information om LaTeX, länkar och annat hittar du på
% http://www.cs.umu.se/~bergner/latex.htm
% En del information om rapportskrivning hittar du på
% http://www.cs.umu.se/~bergner/rapport/
% Det finns massor med information om LaTeX på Internet. Ett litet urval:
% http://www.giss.nasa.gov/latex/
%     är en mycket välfylld sida om LaTeX
% http://wwwinfo.cern.ch/asdoc/WWW/essential/essential.html
%     är en manual som genererats utifrån ett LaTeX-dokument mha latex2html
% http://tex.loria.fr/english/
%     är ett fylligt arkiv av länkar till LaTeX-dokument på Internet
%
% Min personliga favorit är dock manualen "The Not So Short Introduction to
% LaTeX2e", som finns i DVI-format på ~bergner/LaTeX/lshort2e.dvi
% Där står i princip allt man behöver veta. Det är bara att använda xdvi och
% titta efter det du söker, vilket oftast finns där.
% Om du, precis som jag, vill kunna leka med många kommandon i LaTeX finns en
% "LaTeX Command Summary" på ~bergner/LaTeX/latexcmds.ps
