%______________________________________________________
%
%   LaTeX-mall för nybörjare
%
%   Konstruerad av Marcus Bergner, bergner@cs.umu.se
%
%   Vid funderingar titta längst ned i denna fil,
%   eller skicka ett mail
%______________________________________________________
%

% lite inställningar
\documentclass[10pt, titlepage, oneside, a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage[swedish]{babel}
\usepackage{amssymb, graphicx, fancyheadings}
\usepackage{graphicx}
\usepackage{listings}
 \usepackage{float}
% Ursäkta lite bloat men det behövs för att få highlighting på GLSL
\lstdefinelanguage{GLSL}
{
sensitive=true,
morekeywords=[1]{
attribute, const, uniform, varying,
layout, centroid, flat, smooth,
noperspective, break, continue, do,
for, while, switch, case, default, if,
else, in, out, inout, float, int, void,
bool, true, false, invariant, discard,
return, mat2, mat3, mat4, mat2x2, mat2x3,
mat2x4, mat3x2, mat3x3, mat3x4, mat4x2,
mat4x3, mat4x4, vec2, vec3, vec4, ivec2,
ivec3, ivec4, bvec2, bvec3, bvec4, uint,
uvec2, uvec3, uvec4, lowp, mediump, highp,
precision, sampler1D, sampler2D, sampler3D,
samplerCube, sampler1DShadow,
sampler2DShadow, samplerCubeShadow,
sampler1DArray, sampler2DArray,
sampler1DArrayShadow, sampler2DArrayShadow,
isampler1D, isampler2D, isampler3D,
isamplerCube, isampler1DArray,
isampler2DArray, usampler1D, usampler2D,
usampler3D, usamplerCube, usampler1DArray,
usampler2DArray, sampler2DRect,
sampler2DRectShadow, isampler2DRect,
usampler2DRect, samplerBuffer,
isamplerBuffer, usamplerBuffer, sampler2DMS,
isampler2DMS, usampler2DMS,
sampler2DMSArray, isampler2DMSArray,
usampler2DMSArray, struct},
morekeywords=[2]{
radians,degrees,sin,cos,tan,asin,acos,atan,
atan,sinh,cosh,tanh,asinh,acosh,atanh,pow,
exp,log,exp2,log2,sqrt,inversesqrt,abs,sign,
floor,trunc,round,roundEven,ceil,fract,mod,modf,
min,max,clamp,mix,step,smoothstep,isnan,isinf,
floatBitsToInt,floatBitsToUint,intBitsToFloat,
uintBitsToFloat,length,distance,dot,cross,
normalize,faceforward,reflect,refract,
matrixCompMult,outerProduct,transpose,
determinant,inverse,lessThan,lessThanEqual,
greaterThan,greaterThanEqual,equal,notEqual,
any,all,not,textureSize,texture,textureProj,
textureLod,textureOffset,texelFetch,
texelFetchOffset,textureProjOffset,
textureLodOffset,textureProjLod,
textureProjLodOffset,textureGrad,
textureGradOffset,textureProjGrad,
textureProjGradOffset,texture1D,texture1DProj,
texture1DProjLod,texture2D,texture2DProj,
texture2DLod,texture2DProjLod,texture3D,
texture3DProj,texture3DLod,texture3DProjLod,
textureCube,textureCubeLod,shadow1D,shadow2D,
shadow1DProj,shadow2DProj,shadow1DLod,
shadow2DLod,shadow1DProjLod,shadow2DProjLod,
dFdx,dFdy,fwidth,noise1,noise2,noise3,noise4,
EmitVertex,EndPrimitive},
morekeywords=[3]{
gl_VertexID,gl_InstanceID,gl_Position,
gl_PointSize,gl_ClipDistance,gl_PerVertex,
gl_Layer,gl_ClipVertex,gl_FragCoord,
gl_FrontFacing,gl_ClipDistance,gl_FragColor,
gl_FragData,gl_MaxDrawBuffers,gl_FragDepth,
gl_PointCoord,gl_PrimitiveID,
gl_MaxVertexAttribs,gl_MaxVertexUniformComponents,
gl_MaxVaryingFloats,gl_MaxVaryingComponents,
gl_MaxVertexOutputComponents,
gl_MaxGeometryInputComponents,
gl_MaxGeometryOutputComponents,
gl_MaxFragmentInputComponents,
gl_MaxVertexTextureImageUnits,
gl_MaxCombinedTextureImageUnits,
gl_MaxTextureImageUnits,
gl_MaxFragmentUniformComponents,
gl_MaxDrawBuffers,gl_MaxClipDistances,
gl_MaxGeometryTextureImageUnits,
gl_MaxGeometryOutputVertices,
gl_MaxGeometryOutputVertices,
gl_MaxGeometryTotalOutputComponents,
gl_MaxGeometryUniformComponents,
gl_MaxGeometryVaryingComponents,gl_DepthRange},
morecomment=[l]{//},
morecomment=[s]{/*}{*/},
morecomment=[l][keywordstyle4]{\#},
}
\addtolength{\textheight}{20mm}
\addtolength{\voffset}{-5mm}
\renewcommand{\sectionmark}[1]{\markleft{#1}}

% \Section ger mindre spillutrymme, använd dem om du vill
\newcommand{\Section}[1]{\section{#1}\vspace{-8pt}}
\newcommand{\Subsection}[1]{\vspace{-4pt}\subsection{#1}\vspace{-8pt}}
\newcommand{\Subsubsection}[1]{\vspace{-4pt}\subsubsection{#1}\vspace{-8pt}}
	
% appendices, \appitem och \appsubitem är för bilagor
\newcounter{appendixpage}

\newenvironment{appendices}{
	\setcounter{appendixpage}{\arabic{page}}
	\stepcounter{appendixpage}
}{
}

\newcommand{\appitem}[2]{
	\stepcounter{section}
	\addtocontents{toc}{\protect\contentsline{section}{\numberline{\Alph{section}}#1}{\arabic{appendixpage}}}
	\addtocounter{appendixpage}{#2}
}

\newcommand{\appsubitem}[2]{
	\stepcounter{subsection}
	\addtocontents{toc}{\protect\contentsline{subsection}{\numberline{\Alph{section}.\arabic{subsection}}#1}{\arabic{appendixpage}}}
	\addtocounter{appendixpage}{#2}
}

% Ändra de rader som behöver ändras
\def\inst{teknik och naturvetenskap}
\def\typeofdoc{Projektrapport}
\def\course{Modelleringsprojekt}
%\def\pretitle{Laboration 1}
\def\title{Elements}
\def\name{\\ Niklas Andersson, nikan278 \\
Gabriel Baravdish, gabba873 \\
Joakim Deborg, joade361 \\
Kristofer Janukiewicz, krija286 \\
Marcus Nygren, marny568}
\def\username{c00abc}
%\def\email{\username{}@cs.umu.se}
%\def\path{edu/KURS/lab1}
\def\graders{Anna Lombardi, Ulf Sannemo}


% om du vill referera till katalogen där dina filer ligger kan du 
% använda \fullpath som kommer att vara "~username/edu..." o.s.v.
\def\fullpath{\raisebox{1pt}{$\scriptstyle \sim$}\username/\path}


% Här börjar själva dokumentet
\begin{document}

	% skapar framsidan (om den inte duger: gör helt enkelt en egen)
	\begin{titlepage}
		\thispagestyle{empty}
		\begin{large}
			\begin{tabular}{@{}p{\textwidth}@{}}
				\textbf{LINKÖPINGS UNIVERSITET \hfill \today} \\
				\textbf{Institutionen för \inst} \\
				\textbf{\typeofdoc} \\
			\end{tabular}
		\end{large}
		\vspace{10mm}
		\begin{center}
			%\LARGE{\pretitle} \\
			\huge{\textbf{\course}}\\
			\vspace{10mm}
			\LARGE{\title} \\
			\vspace{15mm}
			\begin{large}
				\begin{tabular}{ll}
					\textbf{Namn} & \name \\
					%\textbf{E-mail} & \texttt{\email} \\
					%\textbf{Sökväg} & \texttt{\fullpath} \\
				\end{tabular}
			\end{large}
			\vfill
			\large{\textbf{Handledare}}\\
			\mbox{\large{\graders}}
		\end{center}
	\end{titlepage}


	% fixar sidfot
	%\lfoot{\footnotesize{\name, \email}}
	\rfoot{\footnotesize{\today}}
	\lhead{\sc\footnotesize\title}
	\rhead{\nouppercase{\sc\footnotesize\leftmark}}
	\pagestyle{fancy}
	\renewcommand{\headrulewidth}{0.2pt}
	\renewcommand{\footrulewidth}{0.2pt}

	%Skapa sammanfattning
	\begin{abstract}
	This is the paper's abstract. This is the paper's abstract.This is the paper's abstract.This is the paper's abstract.This is the paper's abstract.This is the paper's abstract.This is the paper's abstract. This is the paper's abstract.This is the paper's abstract.This is the paper's abstract.This is the paper's abstract.This is the paper's abstract.
	\end{abstract}
	
	% skapar innehållsförteckning.
	% Tänk på att köra latex 2ggr för att uppdatera allt
	\pagenumbering{roman}
	\tableofcontents
	
	% och lägger in en sidbrytning
	\newpage

	\pagenumbering{arabic}

	% i Sverige har vi normalt inget indrag vid nytt stycke
	\setlength{\parindent}{0pt}
	% men däremot lite mellanrum
	\setlength{\parskip}{10pt}

	\Section{Introduktion}
		Elements är en programvara som utför fluid-simuleringar baserade på Navier-Stokes ekvationer. Programmet visar i dagsläget endast rök, men systemet är utformat för att i framtiden kunna byggas ut med eld och vatten samt ökad funktionalitet. Visionen med Elements är att användaren ska kunna utforska Navier-Stokes ekvationer med hjälp av att experimentera med olika interaktiva realtidssimuleringar.

%		Målet med projektet har varit att utmanas tekniskt, kombinera medieteknik och datateknik, erfara modellering och simulering, och genom projektet bidra till ökad kunskap hos andra.
	
		
	\Section{Modellering}

	\Subsection{Förklaring av Navier-Stokes ekvationer}
		Navier-Stokes ekvationer, se ekvation $ \ref{eq:Navier-Stokes} $ och $ \ref{eq:Konservering av massa} $, som modellerar en fluid ser på fluiden som en kontinuerlig substans där hela volymen studeras. Ekvationerna i sig bygger på konservering av massa, rörelsemängd och energi och härstammar från ett antal volym- och yt-integraler över en godtycklig volym, se Reynolds Transport Theorem (RTT), ekvation $ \ref{eq:Reynolds Transport Theorem Orginal} $.
		
	\begin{center}
		\begin{equation}\label{eq:Navier-Stokes}
			\bold \varrho \left ( \frac{\partial }{\partial t} \bold u + \bold u \cdot \nabla \bold u \right ) 
			= 
			- \nabla p
			+ \nabla \cdot \bold \Gamma + \bold f
		\end{equation}	
		
		\begin{equation}\label{eq:Konservering av massa}
		 	\nabla \cdot \bold u = 0 
		\end{equation}
	\end{center}
			
	\Subsection{Konservering av energi}
		 RTT säger att summan av en fysisk egenskap $ \psi  $ (antingen skalär- eller vektor-baserad) definerad på volymen $ \Omega $ måste vara lika med vad som är förändrat genom randen till $ \Omega $ plus vad som är förändrat innuti $ \Omega $ genom eventuella källor och sänkor. Detta i enlighet med ekvation $ \ref{eq:Reynolds Transport Theorem Orginal} $ för att bevara energin.
	
	\begin{center}
		\begin{equation}\label{eq:Reynolds Transport Theorem Orginal}
			\frac{\partial }{\partial t}\int_{\Omega}^{ } \psi\ \mathrm{d}V  
			+ \int_{\partial\Omega}^{ } \psi \bold u \cdot \bold n \ \mathrm{d}A 
			+ \int_{\Omega}^{ } \chi \ \mathrm{d}V
			=
			0
		\end{equation}
	\end{center}

	\begin{center}
		\begin{equation}\label{eq:Reynolds Transport Theorem}
			\frac{\partial }{\partial t}\int_{\Omega}^{ } \psi\ \mathrm{d}V 
			= 
			- \int_{\partial\Omega}^{ } \psi \bold u \cdot \bold n \ \mathrm{d}A 
			- \int_{\Omega}^{ } \chi \ \mathrm{d}V
		\end{equation}
	\end{center}
	
	\begin{center}
		\begin{equation}\label{eq:Reynolds Transport Theorem 2}
			\frac{\partial }{\partial t}\int_{\Omega}^{ } \psi\ \mathrm{d}V 
			= 
			- \int_{\Omega}^{ } \nabla \cdot \left (  \psi \bold u \right ) \mathrm{d}V
			- \int_{\Omega}^{ } \chi   \ \mathrm{d} V
		\end{equation}
	\end{center}
	
	Leibniz lag säger att vi kan flytta in derivatan.
	\begin{center}
		\begin{equation}\label{eq:Reynolds Transport Theorem 3}
			\int_{\Omega}^{ } \frac{\partial }{\partial t} \psi\ \mathrm{d}V
			+ \int_{\Omega}^{ } \nabla \cdot \left (  \psi \bold u \right ) \mathrm{d}V
			+ \int_{\Omega}^{ } \chi   \ \mathrm{d} V
			=
			0
		\end{equation}
	\end{center}
	
	\begin{center}
		\begin{equation}\label{eq:Reynolds Transport Theorem Leibniz}
			\int_{\Omega}^{ } \left ( \frac{  \partial }{\partial t} \psi\ 
			+ \nabla \cdot \left (  \psi \bold u \right ) 
			+ \chi  \right ) \mathrm{d}V
			= 
			0
		\end{equation}
	\end{center}
	
	Eftersom integralen i ekvation $ \ref{eq:Reynolds Transport Theorem Leibniz} $ ska vara lika med noll för alla volymer $ \Omega $ erhålls ekvation $ \ref{eq:Reynolds Transport Theorem Leibniz 2} $.
	
	\begin{center}
		\begin{equation}\label{eq:Reynolds Transport Theorem Leibniz 2}
			\frac{  \partial }{\partial t} \psi\ 
			+ \nabla \cdot \left (  \psi \bold u \right ) 
			+ \chi 
			= 
			0
		\end{equation}
	\end{center}
	
	
	\Subsection{Konservering av massa}
	Här är $ \psi = \varrho $ och då det inte finns några källor eller sänkor av massa blir $ \chi  $ lika med noll, detta i enlighet med ekvation $ \ref{eq:Konservering av massa 1} $.
	
	\begin{center}
		\begin{equation}\label{eq:Konservering av massa 1}
			\frac{  \partial }{\partial t} \varrho \ 
			+ \nabla \cdot \left (  \varrho \bold u \right ) 
			= 
			0
		\end{equation}
	\end{center}
	
	Om $ \varrho $ fixeras till en konstant leder det till att $ \frac{  \partial }{\partial t} \varrho \  = 0 $ och att $ \nabla \cdot \left (  \varrho \bold u \right ) = 0 $. Det senare villkoret leder fram till sambandet om konserverandet av massa, se ekvation $ \ref{eq:Konservering av massa} $, som ofta ackompinerar Navier-Stokes ekvation, $ \ref{eq:Navier-Stokes} $. Sambandet innebär att fluiden är inkompressibel, det vill säga att fluiden alltid behåller sin ursprungliga volym.
	
	
	\Subsection{Konservering av rörelsemängd}
	Från rörelsemängd, $ p = m\bold u $, fås att $ \psi = \varrho \bold u $, vilket ger ekvation $ \ref{eq:Konservering av rörelsemängd} $.
	
	\begin{center}
		\begin{equation}\label{eq:Konservering av rörelsemängd}
			\frac{  \partial }{\partial t} \varrho \bold u \ 
			+ \nabla \cdot \left ( \varrho \bold u  \bold u \right ) 
			+ \chi 
			= 
			0
		\end{equation}
	\end{center}
	
	Utveckling av ekvation $ \ref{eq:Konservering av rörelsemängd} $ ger ekvation $ \ref{eq:Konservering av rörelsemängd 2} $, där $ \bold b $ representerar en källa eller sänka. 
	
	\begin{center}
		\begin{equation}\label{eq:Konservering av rörelsemängd 2}
			\bold u \frac{  \partial }{\partial t} \varrho \ 
			+ \varrho \frac{  \partial }{\partial t} \bold u \ 
			+ \bold u  \bold u \  \cdot \nabla \varrho
			+ \varrho \bold u \cdot \nabla \bold u
			+ \varrho \bold u \nabla \cdot \bold u
			= \bold b
		\end{equation}
	\end{center}
		
	Ytterliggare omskrivning av ekvation $ \ref{eq:Konservering av rörelsemängd 2} $ ger ekvation $ \ref{eq:Konservering av rörelsemängd 3} $.
	
	\begin{center}
		\begin{equation}\label{eq:Konservering av rörelsemängd 3}
			\bold u \left ( \frac{  \partial }{\partial t} \varrho + \bold u \cdot \nabla \varrho + \varrho \nabla \cdot \bold u \right ) 
			+ \varrho \left ( \frac{  \partial }{\partial t} \bold u 
			+ \bold u \cdot \nabla \bold u \right )
			= \bold b
		\end{equation}
	\end{center}
	
	I ekvation $ \ref{eq:Konservering av rörelsemängd 3} $ innehåller den första termen sambandet om konservering av massa, ekvation $ \ref{eq:Konservering av massa 1} $, då
	$ \bold u \cdot \nabla \varrho + \varrho \nabla \cdot \bold u 
	= \nabla \cdot \left ( \varrho \bold u \right ) $. Detta medför att denna term måste vara lika med noll, vilket innebär att kvar blir ekvation $ \ref{eq:Konservering av rörelsemängd 4} $.
	
	\begin{center}
		\begin{equation}\label{eq:Konservering av rörelsemängd 4}
			 \varrho \left ( \frac{  \partial }{\partial t} \bold u 
			+ \bold u \cdot \nabla \bold u \right )
			= \bold b
		\end{equation}
	\end{center}
	
	Utveckling av ekvation $ \ref{eq:Konservering av rörelsemängd 4} $ ger ett samband som kan knytas till Newtons andra lag, $ \bold F = m \bold a $, se ekvation  $ \ref{eq:Konservering av rörelsemängd 5} $ och $ \ref{eq:Konservering av rörelsemängd 6} $, där $ \varrho $ representerar massan $ m $, $ \bold b $ yttre krafter $ \bold F $ och där materialderivatan för $ \bold u $ representerar accelerationen $ \bold a $. 
	
	\begin{center}
		\begin{equation}\label{eq:Konservering av rörelsemängd 5}
			\varrho \left ( 
			\frac{\partial \bold u }{\partial t}
			+  u _{x} \frac{\partial u _{x}} {\partial x} 
			+  u _{y} \frac{\partial u _{y}} {\partial y} 
			+  u _{z} \frac{\partial u _{z}} {\partial z} 
			\right )
			=
			\bold b
		\end{equation}
	\end{center}

	\begin{center}
		\begin{equation}\label{eq:Konservering av rörelsemängd 6}
			\varrho \
			\frac{\partial }{\partial t} 
			\bold u(x,y,z,t)
			=
			\bold b
		\end{equation}
	\end{center}
	
	Genom att studera en voxel i en fluid fås att kraften $ \bold b $ kan delas upp i två termer engligt $ \bold b =   \nabla \cdot \sigma + \bold f $, där $ \nabla \cdot \sigma $ härstammar från tryck och där $ \bold f $ härstammar från yttre krafter. Cauchys spänningstensor $ \sigma $ kan förenklas till $ \sigma = -pI +  \bold \Gamma \ $, där $ p $ är minus medelvärdet av det normala trycket i $ x $-, $ y $- och $ z $-led, $ I $ är identitesmatrisen och där $ \bold \Gamma $ är en deriverbar spänningstensor. För en fluid i vila är exempelvis $ \bold \Gamma = 0 $. Detta resulterar i ekvation $ \ref{eq:Konservering av rörelsemängd 9} $ som är Navier-Stokes ekvation.
		
	\begin{center}
		\begin{equation}\label{eq:Konservering av rörelsemängd 7}
			 \varrho \left ( \frac{  \partial }{\partial t} \bold u 
			+ \bold u \cdot \nabla \bold u \right )
			= 
			\nabla \cdot \sigma + \bold f
		\end{equation}
	\end{center}
	
	\begin{center}
		\begin{equation}\label{eq:Konservering av rörelsemängd 8}
		 \varrho \left ( \frac{  \partial }{\partial t} \bold u 
			+ \bold u \cdot \nabla \bold u \right )
			= 
			\nabla \cdot \left ( -pI +  \bold \Gamma \right ) + \bold f
		\end{equation}
	\end{center}
	
	\begin{center}
		\begin{equation}\label{eq:Konservering av rörelsemängd 9}
	 \varrho \left ( \frac{  \partial }{\partial t} \bold u 
			+ \bold u \cdot \nabla \bold u \right )
			= 
			- \nabla p + \nabla \cdot \bold \Gamma  + \bold f
		\end{equation}
	\end{center}
	

	
	\Subsection{Val av beräkningsmetod}
	
	Det finns två olika sätt att basera sina beräkningar på, det Euleriska synsättet och det Lagrageiska synsättet. Det Lagrangeiska synsättet ser kontinuumet som ett partikelsystem, där en partikel kan likställas med en enskild molekyl. Tillskillnad från det Lagrangeiska synsättet där enskilda partiklar studeras, bygger istället det Euleriska synsättet på att fixerade punkter i rummet studeras. Fluidens egenskaper som exempelvis hastighet, densitet och temperatur beräknas i varje given punkt.
	
	Vid fluid-simuleringar på GPU lämpar det sig bäst att använda sig av det Euleriska synsättet, eftersom dem intressanta punkterna i rymden med fördel kan placeras i ett rutnät som direkt kan representeras av en textur. Således tillämpas det Euleriska synsättet i det här projektet.

	\Section{Numerisk implementation}

		\Subsection{Implementation av Navier-stokes ekvationer}
För implementaion av Navier-Stokes ekvationerna förenklas 				systemet 	från ekvation $ \ref{eq:Navier-Stokes} $ till
	ekvation $ \ref{eq:Navier-stokes simple} $

		Mer teori och bakgrund finns att hämta i \cite{GPUGems1}.
	\begin{center}
		\begin{equation}\label{eq:Navier-Stokes simple}
			\frac{du}{dt}= -(\bold u \cdot \nabla \bold u) - \frac{1}{ \rho } 				\nabla p + \bold f
		\end{equation}
	\end{center}
	Tillsammans med villkoret i ekvation $\ref{eq:Konservering av massa}$
	
	Ekvation $ \ref{eq:Navier-stokes simple} $ kan brytas ned och beräknas komponentvis. Där 
 	$ \bold u \cdot \nabla \bold u $ beskriver advektion av hastigheten, $ \nabla p $  tryckförändringen i rummet och $\bold f $ är en lämplig extern kraft för simulering av rök. För varje komponent uppdateras rutnätet stegvis tills alla komponenter har beräknats, för att därefter påbörja en ny beräkning.
	
	Den första komponenten som beräknas är advektionen. Advektion av en fysikalisk kvantitet kan beräknas numerisk med olika metoder. En användbar stegmetod för fluider är Eulers implicita stegmetod. Då Eulers explicita metod tenderar att ge okontrollerbar ökning av felet så är den implicita metoden stabil för vissa valda tidssteg och enkel att implementera på GPU:n. Advektionen beräknas genom att spåra kvantiteten bakåt i tiden, därefter beräknas en billinjär interpolation på dem fyra närliggande värdena i rutnätet.


	När adkvetion har genomförts beräknas den andra komponenten, trycket. Trycket beräknas genom att först skapa en vektor $w$, som en summa av två vektorer, enligt ekvation  $ \ref{eq:vektor w} $
	\begin{center}
		\begin{equation}\label{eq:vektor w}
			\bold w = \bold u + \nabla p.
		\end{equation}
	\end{center}
	
	Därefter appliceras divergensoperatorn på ekvation $ \ref{eq:vektor w} $ och tillsammans med villkoret $ \ref{eq:villkor} $ blir resultatet $ \ref{eq:Poissons ekvation} $, Poissons ekvation.
	
	\begin{center}
		\begin{equation}\label{eq:Poissons ekvation}
			\nabla ^2 p = \nabla \cdot \bold w 
		\end{equation}
	\end{center}
	
	I ekvation $ \ref{eq:Poissons ekvation} $ står $\bold w$ för hastigheten som hittills räknats ut av dem tidigare komponenterna i ekvationen. Poissons ekvation kan skrivas om till matrisform, $ \bold A \bold x = \bold b $, där $\bold A $ är byggd från laplacianen, $ \bold b $ är konstanter från $ \bold w $ och $ \bold x $ är den sökta vektorn. Metoden som används för att lösa systemet är Jacobis iterativa metod. Metoden går ut på att först initiera en gissning på en lösning av systemet och sedan iterera fram en förbättrad lösning. Processen är iterativ tills lösningen konvergerar. Det finns olika numeriska metoder till att lösa Poissons ekvation, men tack vare Jacobis enkla struktur utförs beräkningarna snabbt på GPU:n, även om metoden konvergerar långsammare än andra metoder.
	
	För en fullständig lösning på Poissons ekvation krävs hantering av tryck -och hastighets-problem som uppstår vid randen. Hastigheten i randens riktning sätts till 0. För trycket används Neumanns randvillkor, på så sätt att $ \frac{\partial p}{\partial t} = 0 $. 

	Slutligen uppdateras hastigheten med externa krafter. Det finns olika lämpliga externa krafter som verkar på rök. Men för enkelhetens skull har bara en kraft tagits med i implementationen, rökens lyftkraft. Det är en kraft som återfinns i verkliga sammanhang och som beror av temperaturen i rummet och gasens densitet. 
	
	% Mer om hur man tar fram temperaturen och densiteten 	
	\iffalse
	 Temperatur- och densitetsförändringen ges av ekvationerna $ \ref{eq:Temperatur} $ respektive $ \ref{eq:Densitet} $

	\begin{center}
		\begin{equation}\label{eq:Temperatur}
			\frac{\partial T}{\partial t} = -(\bold u \cdot \nabla)T,			
		\end{equation}
	\end{center}
	\begin{center}
		\begin{equation}\label{eq:Densitet}
			\frac{\partial \rho}{\partial t} = -(\bold u \cdot \nabla)\rho.	 
		\end{equation}
	\end{center}
\fi

	Från ekvation $\ref{eq:Navier-stokes simple}$ kan den externa kraften, $ \bold f$, beräknas genom ekvation $\ref{eq:Buoyancy}$.
	\begin{center}
		\begin{equation}\label{eq:Buoyancy}
			\bold f_{buoy} = - \alpha\rho\bold y + \beta(T-T_{amb})\bold y
		\end{equation}
	\end{center}

I $ \ref{eq:Buoyancy} $ är $ \alpha $ och $ \beta $ positiva konstanter så att ekvationen är fysikalisk meningsfull. Temperaturen och den initiala temperaturen är $ T $ respektive $ T_{amb} $. Riktningen hos kraften är $ \bold y = (0,1,0) $



		\Subsection{Simulering i Matlab}
	MATLAB är ett verktyg med inbyggda kommandon som underlättar  beräkningar av matriser. Med programmets kommandon kan en enklare flödessimulering utföras som en förstudie och ökad förståelse. Det är dock svårt att verifiera om en simulering utförs korrekt eftersom programmet saknar visuell funktionalitet. 
\\
\\	
I MATLAB användes samma steg som beskrivs i avsnitt 3.1 Implementation av Navier-Stokes ekvationer. Till skillnad från simuleringen som beskrivs i avsnitt 3.3 OpenGL/GLSL, simplifierades det visuella utseendet för att lösa och förstå dem numeriska problem som kunde uppstå. Simuleringen visade att tidsteget gav varierande resultat och var känslig för mindre ändringar. Det insågs också att $ \alpha $ och $ \beta $ i ekvation $ \ref{eq:Buoyancy} $ har en kraftig påverkan på ekvationen. 
	
		\Subsection{OpenGL/GLSL}
		Realtidssimuleringar av fluider är mycket krävande även för dagens moderna datorer, vilket innebär att metoder för bättre prestanda är eftertraktade. En sådan teknik är att implementera den numeriska lösningen på GPU (istället för CPU), för att utnyttja möjligheten att köra beräkningarna parallellt. Även på moderna processorer är det möjligt att utföra beräkningar parallellt på fyra eller till och med åtta kärnor dock kan detta inte mäta sig med de upp emot 2500 beräkningskärnor som kan tillgås på ett nyare grafikkort.
		
		För GPU-implementationen användes programmeringsspråket C++ med grafikbiblioteket OpenGL för att styra programmet på applikationsnivå. För att komma närmare hårdvaran och kontrollera hur grafikkortet utförde beräkningarna användes även språket GLSL. 

		För att beskriva simuleringen behövdes att antal värden sparas för varje cell i volymen. Dessa värden kan intuitivt representeras som 3d-texturer med olika många komponenter per voxel (volymelement).  Till exempel så kan en hastighet i tre dimensioner lagras som en vektor med tre komponenter. För att spara en hastighet för varje cell i volymen användes en 3d-textur där varje voxel innehåller tre komponenter. För att bestämma hur många komponenter en textur skulle ha användes OpenGL-funktionen i listning~\ref{lst::texImage}. 
\begin{lstlisting}[language=C++, caption = {OpenGL-funktionen för att skapa en 3d-textur.}, label = {lst::texImage}]
void glTexImage3D(
	GLenum target,
 	GLint level,
 	GLint internalFormat,
 	GLsizei width,
 	GLsizei height,
 	GLsizei depth,
 	GLint border,
 	GLenum format,
 	GLenum type,
 	const GLvoid * data);
\end{lstlisting}

De parametrar som kontrollerar antalet komponenter är internalFormat och format. I tabell~\ref{tbl:texturer} visas en lista över de texturer som användes, hur många komponenter de hade och vilka värden som användes på de ovan nämnda parametrarna.

\begin{table}[h]
\begin{center}
\caption{Lista över de olika texturerna som används.}
\label{tbl:texturer}
	 \begin{tabular}{| l | l | l | l |}
	 \hline
		Storhet & Komponenter & internalFormat & format \\ \hline
		Hastighet & 3 & GL\_RGB16F & GL\_RGB \\ \hline
		Densitet & 3 & GL\_RGB16F & GL\_RGB \\ \hline
		Tryck & 1 & GL\_R16F & GL\_RED \\ \hline
		Divergens & 3 & GL\_RGB16F & GL\_RGB \\ \hline
		Temperatur & 1 & GL\_R16F & GL\_RED \\ \hline
	\end{tabular}
\end{center}
\end{table}
För att kunna representera hinder användes ytligare en 3d-textur. För detta krävdes endast en textur med en komponent. Om värdet i denna komponent var större än noll ansågs den voxeln i volymen att ligga i ett hinder. 
För en mer omfattande beskrivning av hur texturer skapas i OpenGL se \cite[s.~138]{OpenGLSuperBible}. \\

För att sedan kunna uppdatera värdena i texturerna användes så kallade \textit{Framebuffer Objects}. Med \textit{Framebuffer Objects} kunde resultatet från grafikkortets beräkningar sparas i texturer i stället för att ritas på skärmen. Varje textur binds till ett \textit{Framebuffer Object} som sedan kan aktiveras innan rendering. Ett problem som behövde hanteras var att OpenGL inte kan rendera direkt till en 3d-textur. Istället behövde texturen delas in i tvådimensionella skivor som sedan renderades till var för sig. För att uppnå maximal prestanda och minska belastningen på CPU användes OpenGL funktionen i listning~\ref{lst:drawInstanced}.

\begin{lstlisting}[language=GLSL, caption={OpenGL funktion för att rendera flera instanser.}, label = {lst:drawInstanced}]
void glDrawArraysInstanced(
	GLenum mode,
	GLint first,
 	GLsizei count,
 	GLsizei primcount); 
\end{lstlisting}

Parametern mode talar om vilken typ av primitiv som ska renderas och sattes i detta fall till GL\_TRIANGLE\_STRIP. first talar om var i vertex listan renderingen ska starta. För den parametern sattes värdet noll då renderingen skulle börja från början av listan. Eftersom det var en quad som ritades sattes count till fyra, det vill säga antalet hörnpunkter som skulle renderas. Den mest intressanta parametern är primcount då den talar om hur många instanser av som ska göras av renderingen. Då volymen delades upp i z-led sattes primcount till djupet på volymen. Vid instansrendering ökas värdet på den inbyggda vertex-shader variabel \textit{gl\_InstanceID} med ett för varje instans. För att använda den variabeln skapades en vertex-shader som sparade den till en \textit{Output} variabel och skickade den vidare till en geometry-shader. Vertex-shader visas i listning~\ref{lst:vertex}. 

\begin{lstlisting}[language=GLSL, caption={Vertex-shader för att hantera instansrendering}, label = {lst:vertex}]
layout (location = 0) in vec4 vertexPosition;
flat out int layerInstance;

void main()
{
  layerInstance = gl_InstanceID; 
  gl_Position = vertexPosition;

}
\end{lstlisting}

En geometry-shader behandlar, till skillnad från vertex-shader, inte enstaka hörnpunkter utan istället hela primitiver. I detta fall användes den för att koppla en instans av renderingen till rätt texturlager. Första steget var att sätta den inbyggda variabeln \textit{gl\_Layer} till värdet på den aktuella instansen. \textit{gl\_Layer} talar om för OpenGL till vilket lager i texturen som är bunden till den aktiverade \textit{Framebuffer Object} som renderingen ska ske. Nästa steg var att ta fram det värdet som skulle användas för åtkomst till ett lager i en bunden textur. Detta kunde inte vara samma som \textit{gl\_Layer} då varje voxel behandlas från centrum men värdet från en textur hämtas från kanten. Detta löstes genom att introducera en förskjutning på 0.5 till värdet på \textit{gl\_Layer}. Slutligen skickade geometry-shadern hörnpunkterna vidare till nästa steg i renderingen. Shadern visas i listning~\ref{lst:geom}.

\begin{lstlisting}[language=GLSL, caption={Geometry-shader för att välja rätt texturlager.}, label = {lst:geom}]
layout(triangles) in;
layout(triangle_strip, max_vertices = 3) out;
 
flat in int layerInstance[3];
out float layer;
 
void main()
{
    gl_Layer = layerInstance[0];
    layer = float(gl_Layer) + 0.5;

    for (int i = 0; i < gl_in.length(); i++)
    {
        gl_Position = gl_in[i].gl_Position;
        EmitVertex();
    }
    EndPrimitive();
}
\end{lstlisting}

De ovan beskrivna vertex- och geometry-shaders är gemensamma för alla beräkningar som utfördes på GPU. Varje beräkning implementerades sedan som en egen fragment-shader. Nedan följer korta beskrivningar av dessa fragment-shaders.

Advektions-termen implementerades i en shader som beräknade det nya värdet på en plats i volymen genom att använda Eulers implicita metod. Med hjälp av texturen som innehöll information om hinder kunde det avgöras om en voxel låg i ett hinder och i så fall sattes värdet där till noll.

För att beräkna lyftkraften som orsakas av temperaturen i volymen 

		
	\Section{Grafisk implementation}

		\Subsection{OpenGL}
		\emph{Varför valde vi OpenGL? Hur fick vi fram renderingen på skärmen?}
		
		\Subsection{Qt}
För att utveckla och skapa ett användagränssnitt i C++ rekommenderas ofta Qt. Det är ett populärt multiplattformsbibliotek för att utveckla GUI:n, med ett egenutvecklat designskriptspråk, QML. Detta språket kommunicerar med C++ via en metod kallad ''Signals \& Slots'' och kan även hantera JavaScript-funktioner.

		%Det upptäcktes dock att medan Qt lämpar sig väldigt väl för att göra ett avancerat GUI, vilket var ett av projektens önskemål, lämpar sig inte biblioteket för att göra avancerad 3D i OpenGL, främst därför att Qt styr över i vilken ordning olika operationer ska utföras, vilket kan vara en försvårande omständighet i mer avancerade grafikapplikationer.

		Inom projektet utvecklades fortfarande ett fungerande GUI som visade på funktionaliteten att användaren via interaktion med till exempel knappar kan kommunicera med C++-lagret. Tyvärr används inte denna implementation alls i resultatet av projektet, då vårt slutgiltiga bibliotek GLFW och Qt inte är kompatibla med varandra. Det skulle vara möjligt att använda Qt, förutsatt att man i början av projektet lägger mycket tid på att abstrahera C++-applikationen och Qt-gränssnittet, och anpassar sig efter de förutsättningar som finns.
				

		\begin{figure}[H]
			\centering
			\includegraphics[width=90mm]{report_images/QtGui}
			\caption{Användargränsnittet skapat i Qt som inte kom med till slutresultatet}
			\label{fig:QtGui}
		\end{figure}
		
		\Subsection{GLFW}
		
		GLFW är ett plattformsoberoende fönsterhanterings-ramverk utan onödiga finesser. GLFW har inte något inbyggt stöd för att göra GUI, men är ett mycket uppskattat ramverk bland utvecklare för att utveckla prestandatunga applikationer i OpenGL. Det som GLFW kan sköta är fönsterhantering och inmatning från bland annat mus och tangentbord.
		
		När GLFW används vid utveckling av en OpenGL-applikationer behövs först ett annat ramverk för att ladda de OpenGL-funktioner som finns tillgängliga på systemet. För detta ändamål användes GLEW. I den här rapporten kommer inte GLEW att beskrivas i detalj. Det finns många bibliotek med samma funktionalitet och valet mellan dessa spelar inte någon större roll.

		Resultatet från den numeriska lösningen är en 3d-textur som innehåller diskreta värden för densitetens utbredning i fluiden. 3d-texturen visualiseras genom att ett 2d-plan plockas ut vid ett diskret z-värde i mitten av volymen för att sedan mappas till en quad som täcker hela \textit{viewport}:en. Detta görs genom att rendera två trianglar som tillsammans bildar en rektangel och fyller hela skärmen. Hörnpunkterna skickas sedan till en vertex-shader som inte utför några beräkningar utan endast skickar den vidare. Det är först när de enskilda fragmenten ska behandlas som något meningsfullt sker. Här behandlas varje fragment av en fragment-shader som hämtar ett värde ur den bundna 3d-texturen beroende på fragmentets koordinater samt vilken nivå i z-led som ska visas. Viktigt att notera är att fragmentets koordinater antar värden mellan noll och fönstretsstorlek medan texturkoordinater ges mellan noll och ett. Det är alltså nödvändigt för fragment-shadern att veta om fönstret storlek så att koordinaterna kan normaliseras. Fragment-shadern syns i listning~\ref{lst:vizShader}.

\begin{lstlisting}[language=GLSL, caption={Fragment-shader för att visualisera ett lager ur en 3d-textur.}, label = {lst:vizShader}]
out vec3 color;
uniform sampler3D tex;
uniform float layer;
uniform vec3 dimensions;
uniform vec2 windowSize;

void main()
{
  color = texture(tex, vec3(gl_FragCoord.x / windowSize.x ,
  gl_FragCoord.y / windowSize.y, layer/dimensions.z)).xyz;
}
\end{lstlisting} 


	Den ovan nämnda metoden för att visualisera innehållet i en 3d-textur användes för att den är mycket lätt att implementera, dock går en stor del av meningen med att utföra simuleringen i tre dimensioner förlorad. Ett mer tilltalande alternativ hade varit att visualisera hela volymen i tre dimensioner med hjälp av volymrendering. Detta hade dock krävt betydligt mer implementation, vilket var utanför denna kurs ramar.
		

		I figur~\ref{fig:resultat} visas resultatet av att rendera ett lager av 3d-texturen som innehåller densitetens utbredning. De olika punktkällorna har olika densitet, där röken efter en tid breder ut sig och krockar med de cirkulära objekten. Implementationen tillåter en användare att styra den mittersta punktkällan.
	
	\begin{figure}[H]
    	\centering
    	\includegraphics[width=\linewidth]{report_images/resultat.png}
    	\caption{Resultat av simuleringen.}
   		\label{fig:resultat}
	\end{figure}
	
	
	\Section{Diskussion}
		
		Från början gick projektet ut på att utveckla ett gränssnitt i Qt där användaren grafiskt fick modifiera parametrarna och dess värden i Navier-Stokes, med syftet att ge användaren en väldigt pedagogisk koppling mellan ekvationerna och dess visuella representation.

		Om vi hade gjort om projektet hade vi utvecklat applikationen direkt i GLFW med tanke på att kursens tyngd låg i att utforma modellering och simulering, ej att producera en färdig produkt. Alldeles för sent i projektet upptäcktes varför det var så svårt att få en fungerande avancerad grafiska applikationer att fungera i Qt. Så fort projektet bytte fokus till GLFW gick det mycket snabbare att utveckla, även om det innebar att allt GUI-arbete bortprioriterades.

		Med det sagt lämpar sig Qt fortfarande väl för tunga C++-applikationer som gynnas av användargräsnitt, men kraven på hur man utformar programvaran blir mycket högre och en kalkylerad avvägning rekommenderas. För utvecklingsteamet var det uppskattat att lära sig både i Qt och GLFW under en och samma projekt. Det har dock fått följden att gruppen inte kommit så långt som visionen varit i något av systemen - som flera olika fluider, större användarkontroll, 3D-representation, fler externa krafter representerade, etcetera. Resultatet bedöms ändå som framgångsrikt, då de kunskapsmässiga målen för kursen överträffats.

		Att göra applikationen GPU-baserad visade sig vara ett effektivt val. Simuleringen kör i realtid, så det går att interagera med den via piltangenterna, vilket inte hade varit möjligt annars. 

	\Section{Resultat}
		\emph{Projektets resultat. Om man följer hela workflowen i metod-delen vart hamnar man då? Vad kom vi fram till?}
		
		TEXT..

	\Section{Slutord}
		
		Det finns en anledning till att fluidsimuleringar blivit så populära: det är både logiskt och visuellt stimulerande, det finns många appliceringar, och Navier-Stokes ekvationer är fortfarande, 2014, ett av de olösta matematiska millenieproblemen.

		Att som studenter utforska och tillämpa dessa för att skapa denna applikation har varit roligt, utvecklande och bitvis också väldigt utmanande. Om du som läsare vill göra något liknande, rekommenderar vi verkligen att se vilka referenser vi använt som grund för detta arbete. För matematisk teori och implementation av Navier-Stokes ekvationer har vi främst använt \cite{GPUGems1} som referens och för rök-implementation har vi använt \cite{Grasshopper} och \cite{Fedkiw}.

		Förutom referenserna på nästa sida vill vi även tacka vår kurshandledare Anna Lombardi.

	\newpage
	\begin{thebibliography}{9}
		\bibitem{OpenGLSuperBible}
		Graham Sellers, Richard S. Wright, Jr. och Nicholas Haemel, \emph{OpenGL Super Bible, Sixth Edition}, Addison-Wesley 2013
		\bibitem{Fedkiw}
		Ronald Fedkiw, Jos Stam och Henrik Wann Jensen, \emph{Visual Simulation of Smoke}, ACM SIGGRAPH 2001
		\bibitem{GPUGems1}
		Mark J. Harris \emph{Fast Fluid Dynamics Simulation on the GPU, GPU Gems, sida 637, Chapter 38}, NVIDIA och Addison-Wesley 2004
	   \bibitem{GPUGems3}
	   Keenan Crane, Ignacio Llamas och Sarah Tariq \emph{Real-Time Simulation and Rendering of 3D Fluids, GPU Gems 3, Chapter 30, http://http.developer.nvidia.com/GPUGems3/gpugems3\_ch30.html}, NVIDIA 2007
	   \bibitem{Grasshopper}
	   Philip Rideout \emph{Simple Fluid Simulation, http://prideout.net/blog/?p=58}, The Little Grasshopper 2010, 2014-03-11
	\end{thebibliography}
		
	\newpage
	\appendix

	\Section{Bilaga}
	\ldots{}här kan man lägga till bilagor
	
	\newpage
	\Section{Bilaga}
	\ldots{}här kan man lägga till bilagor

	% bilagor, t.ex. källkod. En tom extrasida kommer att skrivas ut för
	% att få alla sidnummer att stämma
	\begin{appendices}
		%\appitem{Källkod}{0}
		%\appsubitem{\texttt{minfil.c}}{2}
		%\appsubitem{\texttt{minfil.h}}{1}
		%\appitem{En bilaga på 3 sidor}{3}
	\end{appendices}

\end{document}


% Lite information om hur man arbetar med LaTeX
%-----------------------------------------------
%
% LaTeX-koden kan skrivas med en godtycklig editor.
% För att "kompilera" dokumentet används kommandot latex:
%    bergner@peppar:~/edu/sysprog/lab1> latex rapportmall.tex
% Resultatet blir ett antal filer, bl.a. en som heter rapportmall.dvi.
% Denna fil kan användas för att titta hur dokumentet egentligen ser
% ut med hjälp av programmet xdvi:
%    bergner@peppar:~/edu/sysprog/lab1> xdvi rapportmall.dvi &
% Du får då upp ett fönster som visar ditt dokument. Detta fönster
% kommer automatiskt att uppdateras då du ändrar och kompilerar om din
% LaTeX-kod. 
% När du anser att din rapport är färdig att skrivas ut använder man
% lämpligtvis kommandona dvips och lpr:
%    bergner@peppar:~/edu/sysprog/lab1> dvips -P ma436ps rapportmall.dvi
% Om man vill ha kvar PostScript-filen som dvips genererar kan man göra:
%    bergner@peppar:~/edu/sysprog/lab1> dvips -o rapport.ps rapportmall.dvi
%    bergner@peppar:~/edu/sysprog/lab1> lpr -P ma436ps rapport.ps
% OBS!!! För att innehållsförteckningen och eventuella referenser till
% tabeller och figurer garanterat ska stämma måste man köra latex 2ggr
% på sitt dokument efter att man har ändrat något.
%
%
% Lite information om saker man kan tänkas behöva i sitt arbete med LaTeX
%-------------------------------------------------------------------------
%
% FORMATTERA TEXT
%
% För att formattera text på lite olika sätt kan man använda följande LaTeX-
% kommandon:
%    \textbf{denna text kommer att vara i fetstil}
%    \emph{denna text är viktig (kursiv stil)}
%    \texttt{i denna text blir alla tecken lika breda, som med en skrivmaskin}
%    \textsf{denna text visas med ett typsnitt utan serifer}
%
%
% MATEMATISKA FORMLER
%
% För att typsätta matematiska formler kan man använda:
%    $f(x) = x^2 - 3$, vilket lägger in formeln i texten, eller
%    \begin{displaymath}
%        g(x) = \frac{\sin x}{x}
%    \end{displaymath}, vilket låter formeln visas centrerat på en egen rad
% Om du vill att en formel ska numreras byter du ut displaymath mot equation.
% Det finns massor med matematiska symboler, vilket gör att man behöver
% någon liten manual att titta i om man ska konstruera avancerade formler.
% Se slutet på filen för lite råd om var du kan hitta sådana.
%
%
% INFOGA FIGURER
%
% För att infoga en figur kan man göra på följande sätt:
%    \begin{figure}[htb]
%        \includegraphics[scale=0.5, angle=90]{exec_flow.eps}
%        \caption{Detta är bildtexten}
%        \label{EXECFLOW}
%    \end{figure}
% Om man vill referera till denna bild i texten skulle man då skriva enligt:
%    ...i figur \ref{EXECFLOW} kan man se att...
% Några små förklaringar till figurer:
%    [htb] = talar om hur latex ska försöka placera bilden (Here, Top, Bottom)
%            Om du använder [!h], innebär det Here!!!
%    scale = kan skala om bilden, om den är skalbar
%    angle = kan rotera bilden
%    exec_flow.eps = filnamnet på bilden. Notera att formatet .EPS används
% För att skapa figurer används lämpligtvis programmet xfig:
%    bergner@peppar:~/edu/sysprog/lab1> xfig &
% Rita (och spara ofta) tills du är klar. Välj sedan "Export" och exportera
% din figur till EPS-format.
% Om man vill kan man använda endast \includegraphics, men det är inte ofta
% man gör det.
%
%
% INFOGA TABELLER
%
% Om man vill skapa en tabell gör man på följande sätt:
%    \begin{table}[htb]
%        \begin{tabular}{|rlp{10cm}|}
%            \hline
%            13 & $17.26$ & En kommentar som kan sträcka sig över flera rader \\
%            \hline
%        \end{tabular}
%        \caption{Tabelltexten...}
%        \label{TBL:MINTABELL}
%    \end{table}
% Om man vill kan man endast använda raderna 2-6, dvs få en tabell utan text
% och nummer. Om man gör på detta vis kommer tabellen alltid att läggas på
% det ställe den skrivs i koden, dvs ungefär samma sak som [!h] -> Here!!!
% Några förklaringar:
%    l, r, c = vänsterjustera, högerjustera eller centrera kolumn
%    p{bredd} = skapa en vänsterjusterad kolumn med en viss bredd
%               kan innehålla flera rader text
%    | = en vertikal linje i tabellen
%    \hline = en horisontell linje i tabellen
%    & = kolumnseparator
%    \\ = radseparator
% Tänk på att tabeller oftast ser bättre ut med ganska få linjer.
%
%
% INFOGA KÄLLKOD ELLER UTDATA FRÅN TESTKÖRNINGAR
%
% Om man vill infoga källkod eller något annat liknande, t.ex. utdata från
% en testkörning är det bra om LaTeX återger utdatan korrekt, dvs en radbrytning
% betyder en radbrytning och 8 mellanslag på rad betyder 8 mellanslag på rad.
% För att åstadkomma detta används:
%    \begin{verbatim}
%        allt som skrivs här återges exakt, med skrivmaskinstypsnitt
%    \end{verbatim}
% Oftast finns det dock bättre verktyg för att skriva ut källkod. Exempel på
% sådana är a2ps, enscript och atp.
%
%
% ÄNDRA STORLEK PÅ TEXT
%
% Om du vill ändra storleken på ett stycke, t.ex. på din nyss infogade
% testkörning omger du stycket med \begin{STORLEK} \end{STORLEK}, där
% STORLEK är någon av:
%    tiny, scriptsize, footnotesize, small, normalsize, large, Large,
%    LARGE, huge, Huge
% Tänk på att inte mixtra för mycket med storlekar bara.
%
%
% SKAPA LISTOR AV OLIKA SLAG
%
% Det är ganska vanligt att man vill rada upp saker på något sätt. För att
% skapa punktlistor används:
%    \begin{itemize}
%        \item Detta är första punkten
%        \item Detta är andra punkten
%    \end{itemize}
% Om man istället vill ha en numrerad lista kan man använda enumerate istället
% för itemize. Listor kan användas i flera nivåer
%
%
% MER INFORMATION OM LaTeX
%
% Lite blandad information om LaTeX, länkar och annat hittar du på
% http://www.cs.umu.se/~bergner/latex.htm
% En del information om rapportskrivning hittar du på
% http://www.cs.umu.se/~bergner/rapport/
% Det finns massor med information om LaTeX på Internet. Ett litet urval:
% http://www.giss.nasa.gov/latex/
%     är en mycket välfylld sida om LaTeX
% http://wwwinfo.cern.ch/asdoc/WWW/essential/essential.html
%     är en manual som genererats utifrån ett LaTeX-dokument mha latex2html
% http://tex.loria.fr/english/
%     är ett fylligt arkiv av länkar till LaTeX-dokument på Internet
%
% Min personliga favorit är dock manualen "The Not So Short Introduction to
% LaTeX2e", som finns i DVI-format på ~bergner/LaTeX/lshort2e.dvi
% Där står i princip allt man behöver veta. Det är bara att använda xdvi och
% titta efter det du söker, vilket oftast finns där.
% Om du, precis som jag, vill kunna leka med många kommandon i LaTeX finns en
% "LaTeX Command Summary" på ~bergner/LaTeX/latexcmds.ps
